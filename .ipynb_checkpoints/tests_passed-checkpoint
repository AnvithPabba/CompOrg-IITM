Using directory : ./test/t1
Compiling sources
RUNNING TEST FROM ./test/t1
Using directory : ./test/t2
Compiling sources
RUNNING TEST FROM ./test/t2
Using directory : ./test/t3
Compiling sources
WARNING: imem.v:9: $readmemh(./test/t3/idata.mem): Not enough words in the file for the requested range [0:4095].
RUNNING TEST FROM ./test/t3
Passed
Running yosys to synthesize cpu.
Ensure that 'synth.ys' lists all the modules needed for the synthesis,
and that the top module is called 'cpu'

 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2019  Clifford Wolf <clifford@clifford.at>           |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.9 (git sha1 1979e0b)


-- Executing script file `synth.ys' --

1. Executing Verilog-2005 frontend: cpu.v
Parsing Verilog input from `cpu.v' to AST representation.
Generating RTLIL representation for module `\cpu'.
Note: Assuming pure combinatorial block at cpu.v:85 in
compliance with IEC 62142(E):2005 / IEEE Std. 1364.1(E):2002. Recommending
use of @* instead of @(...) for better match of synthesis and simulation.
Note: Assuming pure combinatorial block at cpu.v:140 in
compliance with IEC 62142(E):2005 / IEEE Std. 1364.1(E):2002. Recommending
use of @* instead of @(...) for better match of synthesis and simulation.
Successfully finished Verilog frontend.

2. Executing Verilog-2005 frontend: alu.v
Parsing Verilog input from `alu.v' to AST representation.
Generating RTLIL representation for module `\ALU'.
Note: Assuming pure combinatorial block at alu.v:19 in
compliance with IEC 62142(E):2005 / IEEE Std. 1364.1(E):2002. Recommending
use of @* instead of @(...) for better match of synthesis and simulation.
Successfully finished Verilog frontend.

3. Executing Verilog-2005 frontend: regfile.v
Parsing Verilog input from `regfile.v' to AST representation.
Generating RTLIL representation for module `\regfile'.
Successfully finished Verilog frontend.

4. Executing Verilog-2005 frontend: immgen.v
Parsing Verilog input from `immgen.v' to AST representation.
Generating RTLIL representation for module `\immGen'.
Note: Assuming pure combinatorial block at immgen.v:7 in
compliance with IEC 62142(E):2005 / IEEE Std. 1364.1(E):2002. Recommending
use of @* instead of @(...) for better match of synthesis and simulation.
Successfully finished Verilog frontend.

5. Executing Verilog-2005 frontend: control.v
Parsing Verilog input from `control.v' to AST representation.
Generating RTLIL representation for module `\Control'.
Note: Assuming pure combinatorial block at control.v:18 in
compliance with IEC 62142(E):2005 / IEEE Std. 1364.1(E):2002. Recommending
use of @* instead of @(...) for better match of synthesis and simulation.
Successfully finished Verilog frontend.

6. Executing SYNTH_XILINX pass.

6.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/cells_sim.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/cells_sim.v' to AST representation.
Generating RTLIL representation for module `\VCC'.
Generating RTLIL representation for module `\GND'.
Generating RTLIL representation for module `\IBUF'.
Generating RTLIL representation for module `\OBUF'.
Generating RTLIL representation for module `\BUFG'.
Generating RTLIL representation for module `\BUFGCTRL'.
Generating RTLIL representation for module `\BUFHCE'.
Generating RTLIL representation for module `\INV'.
Generating RTLIL representation for module `\LUT1'.
Generating RTLIL representation for module `\LUT2'.
Generating RTLIL representation for module `\LUT3'.
Generating RTLIL representation for module `\LUT4'.
Generating RTLIL representation for module `\LUT5'.
Generating RTLIL representation for module `\LUT6'.
Generating RTLIL representation for module `\LUT6_2'.
Generating RTLIL representation for module `\MUXCY'.
Generating RTLIL representation for module `\MUXF7'.
Generating RTLIL representation for module `\MUXF8'.
Generating RTLIL representation for module `\XORCY'.
Generating RTLIL representation for module `\CARRY4'.
Generating RTLIL representation for module `\FDRE'.
Generating RTLIL representation for module `\FDSE'.
Generating RTLIL representation for module `\FDCE'.
Generating RTLIL representation for module `\FDPE'.
Generating RTLIL representation for module `\FDRE_1'.
Generating RTLIL representation for module `\FDSE_1'.
Generating RTLIL representation for module `\FDCE_1'.
Generating RTLIL representation for module `\FDPE_1'.
Generating RTLIL representation for module `\RAM32X1D'.
Generating RTLIL representation for module `\RAM64X1D'.
Generating RTLIL representation for module `\RAM128X1D'.
Generating RTLIL representation for module `\SRL16E'.
Generating RTLIL representation for module `\SRLC32E'.
Successfully finished Verilog frontend.

6.2. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/cells_xtra.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/cells_xtra.v' to AST representation.
Generating RTLIL representation for module `\BSCANE2'.
Generating RTLIL representation for module `\BUFGCE'.
Generating RTLIL representation for module `\BUFGCE_1'.
Generating RTLIL representation for module `\BUFGMUX'.
Generating RTLIL representation for module `\BUFGMUX_1'.
Generating RTLIL representation for module `\BUFGMUX_CTRL'.
Generating RTLIL representation for module `\BUFH'.
Generating RTLIL representation for module `\BUFIO'.
Generating RTLIL representation for module `\BUFMR'.
Generating RTLIL representation for module `\BUFMRCE'.
Generating RTLIL representation for module `\BUFR'.
Generating RTLIL representation for module `\CAPTUREE2'.
Generating RTLIL representation for module `\CFGLUT5'.
Generating RTLIL representation for module `\DCIRESET'.
Generating RTLIL representation for module `\DNA_PORT'.
Generating RTLIL representation for module `\DSP48E1'.
Generating RTLIL representation for module `\EFUSE_USR'.
Generating RTLIL representation for module `\FIFO18E1'.
Generating RTLIL representation for module `\FIFO36E1'.
Generating RTLIL representation for module `\FRAME_ECCE2'.
Generating RTLIL representation for module `\GTHE2_CHANNEL'.
Generating RTLIL representation for module `\GTHE2_COMMON'.
Generating RTLIL representation for module `\GTPE2_CHANNEL'.
Generating RTLIL representation for module `\GTPE2_COMMON'.
Generating RTLIL representation for module `\GTXE2_CHANNEL'.
Generating RTLIL representation for module `\GTXE2_COMMON'.
Generating RTLIL representation for module `\IBUF_IBUFDISABLE'.
Generating RTLIL representation for module `\IBUF_INTERMDISABLE'.
Generating RTLIL representation for module `\IBUFDS'.
Generating RTLIL representation for module `\IBUFDS_DIFF_OUT'.
Generating RTLIL representation for module `\IBUFDS_DIFF_OUT_IBUFDISABLE'.
Generating RTLIL representation for module `\IBUFDS_DIFF_OUT_INTERMDISABLE'.
Generating RTLIL representation for module `\IBUFDS_GTE2'.
Generating RTLIL representation for module `\IBUFDS_IBUFDISABLE'.
Generating RTLIL representation for module `\IBUFDS_INTERMDISABLE'.
Generating RTLIL representation for module `\ICAPE2'.
Generating RTLIL representation for module `\IDDR'.
Generating RTLIL representation for module `\IDDR_2CLK'.
Generating RTLIL representation for module `\IDELAYCTRL'.
Generating RTLIL representation for module `\IDELAYE2'.
Generating RTLIL representation for module `\IN_FIFO'.
Generating RTLIL representation for module `\IOBUF'.
Generating RTLIL representation for module `\IOBUF_DCIEN'.
Generating RTLIL representation for module `\IOBUF_INTERMDISABLE'.
Generating RTLIL representation for module `\IOBUFDS'.
Generating RTLIL representation for module `\IOBUFDS_DCIEN'.
Generating RTLIL representation for module `\IOBUFDS_DIFF_OUT'.
Generating RTLIL representation for module `\IOBUFDS_DIFF_OUT_DCIEN'.
Generating RTLIL representation for module `\IOBUFDS_DIFF_OUT_INTERMDISABLE'.
Generating RTLIL representation for module `\ISERDESE2'.
Generating RTLIL representation for module `\KEEPER'.
Generating RTLIL representation for module `\LDCE'.
Generating RTLIL representation for module `\LDPE'.
Generating RTLIL representation for module `\MMCME2_ADV'.
Generating RTLIL representation for module `\MMCME2_BASE'.
Generating RTLIL representation for module `\OBUFDS'.
Generating RTLIL representation for module `\OBUFT'.
Generating RTLIL representation for module `\OBUFTDS'.
Generating RTLIL representation for module `\ODDR'.
Generating RTLIL representation for module `\ODELAYE2'.
Generating RTLIL representation for module `\OSERDESE2'.
Generating RTLIL representation for module `\OUT_FIFO'.
Generating RTLIL representation for module `\PHASER_IN'.
Generating RTLIL representation for module `\PHASER_IN_PHY'.
Generating RTLIL representation for module `\PHASER_OUT'.
Generating RTLIL representation for module `\PHASER_OUT_PHY'.
Generating RTLIL representation for module `\PHASER_REF'.
Generating RTLIL representation for module `\PHY_CONTROL'.
Generating RTLIL representation for module `\PLLE2_ADV'.
Generating RTLIL representation for module `\PLLE2_BASE'.
Generating RTLIL representation for module `\PS7'.
Generating RTLIL representation for module `\PULLDOWN'.
Generating RTLIL representation for module `\PULLUP'.
Generating RTLIL representation for module `\RAM128X1S'.
Generating RTLIL representation for module `\RAM256X1S'.
Generating RTLIL representation for module `\RAM32M'.
Generating RTLIL representation for module `\RAM32X1S'.
Generating RTLIL representation for module `\RAM32X1S_1'.
Generating RTLIL representation for module `\RAM32X2S'.
Generating RTLIL representation for module `\RAM64M'.
Replacing existing blackbox module `\RAM64X1D' at /usr/bin/../share/yosys/xilinx/cells_xtra.v:3741.
Generating RTLIL representation for module `\RAM64X1D'.
Generating RTLIL representation for module `\RAM64X1S'.
Generating RTLIL representation for module `\RAM64X1S_1'.
Generating RTLIL representation for module `\RAM64X2S'.
Generating RTLIL representation for module `\ROM128X1'.
Generating RTLIL representation for module `\ROM256X1'.
Generating RTLIL representation for module `\ROM32X1'.
Generating RTLIL representation for module `\ROM64X1'.
Generating RTLIL representation for module `\STARTUPE2'.
Generating RTLIL representation for module `\USR_ACCESSE2'.
Generating RTLIL representation for module `\XADC'.
Successfully finished Verilog frontend.

6.3. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/brams_bb.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/brams_bb.v' to AST representation.
Generating RTLIL representation for module `\RAMB18E1'.
Generating RTLIL representation for module `\RAMB36E1'.
Successfully finished Verilog frontend.

6.4. Executing HIERARCHY pass (managing design hierarchy).

6.4.1. Analyzing design hierarchy..
Top module:  \cpu
Used module:     \ALU
Used module:     \regfile
Used module:     \Control
Used module:     \immGen

6.4.2. Analyzing design hierarchy..
Top module:  \cpu
Used module:     \ALU
Used module:     \regfile
Used module:     \Control
Used module:     \immGen
Removed 0 unused modules.

6.5. Executing SYNTH pass.

6.5.1. Executing PROC pass (convert processes to netlists).

6.5.1.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

6.5.1.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed 2 dead cases from process $proc$control.v:18$257 in module Control.
Marked 9 switch rules as full_case in process $proc$control.v:18$257 in module Control.
Removed 1 dead cases from process $proc$immgen.v:7$254 in module immGen.
Marked 2 switch rules as full_case in process $proc$immgen.v:7$254 in module immGen.
Marked 1 switch rules as full_case in process $proc$regfile.v:16$144 in module regfile.
Marked 3 switch rules as full_case in process $proc$alu.v:19$67 in module ALU.
Removed 2 dead cases from process $proc$cpu.v:140$65 in module cpu.
Marked 6 switch rules as full_case in process $proc$cpu.v:140$65 in module cpu.
Removed 1 dead cases from process $proc$cpu.v:85$63 in module cpu.
Marked 5 switch rules as full_case in process $proc$cpu.v:85$63 in module cpu.
Marked 3 switch rules as full_case in process $proc$cpu.v:39$1 in module cpu.
Removed a total of 6 dead cases.

6.5.1.3. Executing PROC_INIT pass (extract init attributes).

6.5.1.4. Executing PROC_ARST pass (detect async resets in processes).

6.5.1.5. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\Control.$proc$control.v:18$257'.
     1/26: $9\ALU_out_r[3:0]
     2/26: $8\ALU_out_r[3:0]
     3/26: $7\ALU_out_r[3:0]
     4/26: $6\ALU_out_r[3:0]
     5/26: $5\ALU_out_r[3:0]
     6/26: $4\ALU_out_r[3:0]
     7/26: $3\ALU_out_r[3:0]
     8/26: $2\ALU_out_r[3:0]
     9/26: $1\ALU_out_r[3:0]
    10/26: $1\rd_r[4:0]
    11/26: $1\rs2_r[4:0]
    12/26: $1\rs1_r[4:0]
    13/26: $1\RegWrite_r[0:0]
    14/26: $1\AluSrc_r[0:0]
    15/26: $1\MemtoReg_r[0:0]
    16/26: $1\branch_r[0:0]
    17/26: $1\jump_r[0:0]
    18/26: $0\ALU_out_r[3:0]
    19/26: $0\rd_r[4:0]
    20/26: $0\rs2_r[4:0]
    21/26: $0\rs1_r[4:0]
    22/26: $0\RegWrite_r[0:0]
    23/26: $0\AluSrc_r[0:0]
    24/26: $0\MemtoReg_r[0:0]
    25/26: $0\jump_r[0:0]
    26/26: $0\branch_r[0:0]
Creating decoders for process `\immGen.$proc$immgen.v:7$254'.
     1/3: $2\imm_r[31:0]
     2/3: $1\imm_r[31:0]
     3/3: $0\imm_r[31:0]
Creating decoders for process `\regfile.$proc$regfile.v:11$189'.
     1/65: $0\i[31:0]
     2/65: $0$memwr$\Register_File$regfile.v:13$141_DATA[31:0]$253
     3/65: $0$memwr$\Register_File$regfile.v:13$141_ADDR[31:0]$252
     4/65: $0$memwr$\Register_File$regfile.v:13$140_DATA[31:0]$251
     5/65: $0$memwr$\Register_File$regfile.v:13$140_ADDR[31:0]$250
     6/65: $0$memwr$\Register_File$regfile.v:13$139_DATA[31:0]$249
     7/65: $0$memwr$\Register_File$regfile.v:13$139_ADDR[31:0]$248
     8/65: $0$memwr$\Register_File$regfile.v:13$138_DATA[31:0]$247
     9/65: $0$memwr$\Register_File$regfile.v:13$138_ADDR[31:0]$246
    10/65: $0$memwr$\Register_File$regfile.v:13$137_DATA[31:0]$245
    11/65: $0$memwr$\Register_File$regfile.v:13$137_ADDR[31:0]$244
    12/65: $0$memwr$\Register_File$regfile.v:13$136_DATA[31:0]$243
    13/65: $0$memwr$\Register_File$regfile.v:13$136_ADDR[31:0]$242
    14/65: $0$memwr$\Register_File$regfile.v:13$135_DATA[31:0]$241
    15/65: $0$memwr$\Register_File$regfile.v:13$135_ADDR[31:0]$240
    16/65: $0$memwr$\Register_File$regfile.v:13$134_DATA[31:0]$239
    17/65: $0$memwr$\Register_File$regfile.v:13$134_ADDR[31:0]$238
    18/65: $0$memwr$\Register_File$regfile.v:13$133_DATA[31:0]$237
    19/65: $0$memwr$\Register_File$regfile.v:13$133_ADDR[31:0]$236
    20/65: $0$memwr$\Register_File$regfile.v:13$132_DATA[31:0]$235
    21/65: $0$memwr$\Register_File$regfile.v:13$132_ADDR[31:0]$234
    22/65: $0$memwr$\Register_File$regfile.v:13$131_DATA[31:0]$233
    23/65: $0$memwr$\Register_File$regfile.v:13$131_ADDR[31:0]$232
    24/65: $0$memwr$\Register_File$regfile.v:13$130_DATA[31:0]$231
    25/65: $0$memwr$\Register_File$regfile.v:13$130_ADDR[31:0]$230
    26/65: $0$memwr$\Register_File$regfile.v:13$129_DATA[31:0]$229
    27/65: $0$memwr$\Register_File$regfile.v:13$129_ADDR[31:0]$228
    28/65: $0$memwr$\Register_File$regfile.v:13$128_DATA[31:0]$227
    29/65: $0$memwr$\Register_File$regfile.v:13$128_ADDR[31:0]$226
    30/65: $0$memwr$\Register_File$regfile.v:13$127_DATA[31:0]$225
    31/65: $0$memwr$\Register_File$regfile.v:13$127_ADDR[31:0]$224
    32/65: $0$memwr$\Register_File$regfile.v:13$126_DATA[31:0]$223
    33/65: $0$memwr$\Register_File$regfile.v:13$126_ADDR[31:0]$222
    34/65: $0$memwr$\Register_File$regfile.v:13$125_DATA[31:0]$221
    35/65: $0$memwr$\Register_File$regfile.v:13$125_ADDR[31:0]$220
    36/65: $0$memwr$\Register_File$regfile.v:13$124_DATA[31:0]$219
    37/65: $0$memwr$\Register_File$regfile.v:13$124_ADDR[31:0]$218
    38/65: $0$memwr$\Register_File$regfile.v:13$123_DATA[31:0]$217
    39/65: $0$memwr$\Register_File$regfile.v:13$123_ADDR[31:0]$216
    40/65: $0$memwr$\Register_File$regfile.v:13$122_DATA[31:0]$215
    41/65: $0$memwr$\Register_File$regfile.v:13$122_ADDR[31:0]$214
    42/65: $0$memwr$\Register_File$regfile.v:13$121_DATA[31:0]$213
    43/65: $0$memwr$\Register_File$regfile.v:13$121_ADDR[31:0]$212
    44/65: $0$memwr$\Register_File$regfile.v:13$120_DATA[31:0]$211
    45/65: $0$memwr$\Register_File$regfile.v:13$120_ADDR[31:0]$210
    46/65: $0$memwr$\Register_File$regfile.v:13$119_DATA[31:0]$209
    47/65: $0$memwr$\Register_File$regfile.v:13$119_ADDR[31:0]$208
    48/65: $0$memwr$\Register_File$regfile.v:13$118_DATA[31:0]$207
    49/65: $0$memwr$\Register_File$regfile.v:13$118_ADDR[31:0]$206
    50/65: $0$memwr$\Register_File$regfile.v:13$117_DATA[31:0]$205
    51/65: $0$memwr$\Register_File$regfile.v:13$117_ADDR[31:0]$204
    52/65: $0$memwr$\Register_File$regfile.v:13$116_DATA[31:0]$203
    53/65: $0$memwr$\Register_File$regfile.v:13$116_ADDR[31:0]$202
    54/65: $0$memwr$\Register_File$regfile.v:13$115_DATA[31:0]$201
    55/65: $0$memwr$\Register_File$regfile.v:13$115_ADDR[31:0]$200
    56/65: $0$memwr$\Register_File$regfile.v:13$114_DATA[31:0]$199
    57/65: $0$memwr$\Register_File$regfile.v:13$114_ADDR[31:0]$198
    58/65: $0$memwr$\Register_File$regfile.v:13$113_DATA[31:0]$197
    59/65: $0$memwr$\Register_File$regfile.v:13$113_ADDR[31:0]$190
    60/65: $0$memwr$\Register_File$regfile.v:13$112_DATA[31:0]$196
    61/65: $0$memwr$\Register_File$regfile.v:13$112_ADDR[31:0]$195
    62/65: $0$memwr$\Register_File$regfile.v:13$111_DATA[31:0]$194
    63/65: $0$memwr$\Register_File$regfile.v:13$111_ADDR[31:0]$193
    64/65: $0$memwr$\Register_File$regfile.v:13$110_DATA[31:0]$192
    65/65: $0$memwr$\Register_File$regfile.v:13$110_ADDR[31:0]$191
Creating decoders for process `\regfile.$proc$regfile.v:16$144'.
     1/6: $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147
     2/6: $0$memwr$\Register_File$regfile.v:21$142_DATA[31:0]$146
     3/6: $0$memwr$\Register_File$regfile.v:21$142_ADDR[4:0]$145
     4/6: $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150
     5/6: $0$memwr$\Register_File$regfile.v:23$143_DATA[31:0]$149
     6/6: $0$memwr$\Register_File$regfile.v:23$143_ADDR[4:0]$148
Creating decoders for process `\ALU.$proc$alu.v:19$67'.
     1/4: $3\out[31:0]
     2/4: $2\out[31:0]
     3/4: $1\out[31:0]
     4/4: $0\out[31:0]
Creating decoders for process `\cpu.$proc$cpu.v:140$65'.
     1/7: $6\drdata_RF[31:0]
     2/7: $5\drdata_RF[31:0]
     3/7: $4\drdata_RF[31:0]
     4/7: $3\drdata_RF[31:0]
     5/7: $2\drdata_RF[31:0]
     6/7: $1\drdata_RF[31:0]
     7/7: $0\drdata_RF[31:0]
Creating decoders for process `\cpu.$proc$cpu.v:85$63'.
     1/9: $5\dwe_r[3:0]
     2/9: $4\dwe_r[3:0]
     3/9: $3\dwe_r[3:0]
     4/9: $2\dwe_r[3:0]
     5/9: $2\masked_dwdata[31:0]
     6/9: $1\masked_dwdata[31:0]
     7/9: $1\dwe_r[3:0]
     8/9: $0\masked_dwdata[31:0]
     9/9: $0\dwe_r[3:0]
Creating decoders for process `\cpu.$proc$cpu.v:39$1'.
     1/2: $0\start[0:0]
     2/2: $0\iaddr[31:0]

6.5.1.6. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\Control.\branch_r' from process `\Control.$proc$control.v:18$257'.
No latch inferred for signal `\Control.\jump_r' from process `\Control.$proc$control.v:18$257'.
No latch inferred for signal `\Control.\MemtoReg_r' from process `\Control.$proc$control.v:18$257'.
No latch inferred for signal `\Control.\AluSrc_r' from process `\Control.$proc$control.v:18$257'.
No latch inferred for signal `\Control.\RegWrite_r' from process `\Control.$proc$control.v:18$257'.
No latch inferred for signal `\Control.\rs1_r' from process `\Control.$proc$control.v:18$257'.
No latch inferred for signal `\Control.\rs2_r' from process `\Control.$proc$control.v:18$257'.
No latch inferred for signal `\Control.\rd_r' from process `\Control.$proc$control.v:18$257'.
No latch inferred for signal `\Control.\ALU_out_r' from process `\Control.$proc$control.v:18$257'.
No latch inferred for signal `\immGen.\imm_r' from process `\immGen.$proc$immgen.v:7$254'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$113_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.\i' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$110_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$110_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$111_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$111_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$112_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$112_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$113_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$114_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$114_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$115_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$115_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$116_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$116_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$117_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$117_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$118_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$118_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$119_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$119_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$120_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$120_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$121_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$121_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$122_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$122_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$123_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$123_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$124_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$124_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$125_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$125_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$126_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$126_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$127_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$127_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$128_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$128_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$129_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$129_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$130_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$130_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$131_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$131_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$132_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$132_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$133_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$133_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$134_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$134_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$135_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$135_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$136_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$136_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$137_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$137_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$138_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$138_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$139_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$139_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$140_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$140_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$141_ADDR' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\regfile.$memwr$\Register_File$regfile.v:13$141_DATA' from process `\regfile.$proc$regfile.v:11$189'.
No latch inferred for signal `\ALU.\out' from process `\ALU.$proc$alu.v:19$67'.
No latch inferred for signal `\cpu.\drdata_RF' from process `\cpu.$proc$cpu.v:140$65'.
No latch inferred for signal `\cpu.\dwe_r' from process `\cpu.$proc$cpu.v:85$63'.
No latch inferred for signal `\cpu.\masked_dwdata' from process `\cpu.$proc$cpu.v:85$63'.

6.5.1.7. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\regfile.$memwr$\Register_File$regfile.v:21$142_ADDR' using process `\regfile.$proc$regfile.v:16$144'.
  created $dff cell `$procdff$661' with positive edge clock.
Creating register for signal `\regfile.$memwr$\Register_File$regfile.v:21$142_DATA' using process `\regfile.$proc$regfile.v:16$144'.
  created $dff cell `$procdff$662' with positive edge clock.
Creating register for signal `\regfile.$memwr$\Register_File$regfile.v:21$142_EN' using process `\regfile.$proc$regfile.v:16$144'.
  created $dff cell `$procdff$663' with positive edge clock.
Creating register for signal `\regfile.$memwr$\Register_File$regfile.v:23$143_ADDR' using process `\regfile.$proc$regfile.v:16$144'.
  created $dff cell `$procdff$664' with positive edge clock.
Creating register for signal `\regfile.$memwr$\Register_File$regfile.v:23$143_DATA' using process `\regfile.$proc$regfile.v:16$144'.
  created $dff cell `$procdff$665' with positive edge clock.
Creating register for signal `\regfile.$memwr$\Register_File$regfile.v:23$143_EN' using process `\regfile.$proc$regfile.v:16$144'.
  created $dff cell `$procdff$666' with positive edge clock.
Creating register for signal `\cpu.\iaddr' using process `\cpu.$proc$cpu.v:39$1'.
  created $dff cell `$procdff$667' with positive edge clock.
Creating register for signal `\cpu.\start' using process `\cpu.$proc$cpu.v:39$1'.
  created $dff cell `$procdff$668' with positive edge clock.

6.5.1.8. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 9 empty switches in `\Control.$proc$control.v:18$257'.
Removing empty process `Control.$proc$control.v:18$257'.
Found and cleaned up 2 empty switches in `\immGen.$proc$immgen.v:7$254'.
Removing empty process `immGen.$proc$immgen.v:7$254'.
Removing empty process `regfile.$proc$regfile.v:11$189'.
Found and cleaned up 2 empty switches in `\regfile.$proc$regfile.v:16$144'.
Removing empty process `regfile.$proc$regfile.v:16$144'.
Found and cleaned up 3 empty switches in `\ALU.$proc$alu.v:19$67'.
Removing empty process `ALU.$proc$alu.v:19$67'.
Found and cleaned up 6 empty switches in `\cpu.$proc$cpu.v:140$65'.
Removing empty process `cpu.$proc$cpu.v:140$65'.
Found and cleaned up 5 empty switches in `\cpu.$proc$cpu.v:85$63'.
Removing empty process `cpu.$proc$cpu.v:85$63'.
Found and cleaned up 3 empty switches in `\cpu.$proc$cpu.v:39$1'.
Removing empty process `cpu.$proc$cpu.v:39$1'.
Cleaned up 30 empty switches.

6.5.2. Executing OPT_EXPR pass (perform const folding).
Optimizing module Control.
<suppressed ~7 debug messages>
Optimizing module immGen.
<suppressed ~3 debug messages>
Optimizing module regfile.
<suppressed ~2 debug messages>
Optimizing module ALU.
<suppressed ~1 debug messages>
Optimizing module cpu.
<suppressed ~27 debug messages>

6.5.3. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \Control..
Finding unused cells or wires in module \immGen..
Finding unused cells or wires in module \regfile..
Finding unused cells or wires in module \ALU..
Finding unused cells or wires in module \cpu..
Removed 1 unused cells and 263 unused wires.
<suppressed ~6 debug messages>

6.5.4. Executing CHECK pass (checking for obvious problems).
checking module ALU..
checking module Control..
checking module cpu..
checking module immGen..
checking module regfile..
found and reported 0 problems.

6.5.5. Executing OPT pass (performing simple optimizations).

6.5.5.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module ALU.
Optimizing module Control.
Optimizing module cpu.
Optimizing module immGen.
Optimizing module regfile.

6.5.5.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\ALU'.
<suppressed ~9 debug messages>
Finding identical cells in module `\Control'.
<suppressed ~186 debug messages>
Finding identical cells in module `\cpu'.
<suppressed ~126 debug messages>
Finding identical cells in module `\immGen'.
<suppressed ~3 debug messages>
Finding identical cells in module `\regfile'.
Removed a total of 108 cells.

6.5.5.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \ALU..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 2/2 on $mux $procmux$503.
    dead port 2/2 on $mux $procmux$515.
Running muxtree optimizer on module \Control..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 2/2 on $mux $procmux$304.
    dead port 2/2 on $mux $procmux$267.
    dead port 2/2 on $mux $procmux$306.
    dead port 1/2 on $mux $procmux$321.
    dead port 2/2 on $mux $procmux$323.
    dead port 2/2 on $mux $procmux$269.
    dead port 2/2 on $mux $procmux$325.
    dead port 2/2 on $mux $procmux$339.
    dead port 2/2 on $mux $procmux$341.
    dead port 2/2 on $mux $procmux$281.
    dead port 2/2 on $mux $procmux$354.
    dead port 1/2 on $mux $procmux$291.
    dead port 2/2 on $mux $procmux$293.
    dead port 2/2 on $mux $procmux$295.
    dead port 2/2 on $mux $procmux$369.
Running muxtree optimizer on module \cpu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 2/2 on $mux $procmux$535.
    dead port 2/2 on $mux $procmux$537.
    dead port 2/2 on $mux $procmux$547.
    dead port 2/2 on $mux $procmux$549.
    dead port 2/2 on $mux $procmux$560.
    dead port 2/2 on $mux $procmux$562.
    dead port 2/2 on $mux $procmux$575.
    dead port 2/2 on $mux $procmux$577.
    dead port 2/2 on $mux $procmux$587.
    dead port 2/2 on $mux $procmux$597.
    dead port 2/2 on $mux $procmux$599.
    dead port 2/2 on $mux $procmux$608.
    dead port 2/2 on $mux $procmux$610.
    dead port 2/2 on $mux $procmux$621.
    dead port 2/2 on $mux $procmux$623.
    dead port 2/2 on $mux $procmux$631.
    dead port 2/2 on $mux $procmux$639.
Running muxtree optimizer on module \immGen..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 2/2 on $mux $procmux$454.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 35 multiplexer ports.
<suppressed ~24 debug messages>

6.5.5.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \ALU.
  Optimizing cells in module \Control.
    New ctrl vector for $pmux cell $procmux$372: { $procmux$370_CMP $auto$opt_reduce.cc:132:opt_mux$670 $procmux$296_CMP $procmux$270_CMP }
    New ctrl vector for $pmux cell $procmux$393: $auto$opt_reduce.cc:132:opt_mux$672
    New ctrl vector for $pmux cell $procmux$398: $auto$opt_reduce.cc:132:opt_mux$674
    New ctrl vector for $pmux cell $procmux$406: $auto$opt_reduce.cc:132:opt_mux$676
    New ctrl vector for $pmux cell $procmux$415: $auto$opt_reduce.cc:132:opt_mux$678
    New ctrl vector for $pmux cell $procmux$362: { $auto$opt_reduce.cc:132:opt_mux$684 $auto$opt_reduce.cc:132:opt_mux$682 $auto$opt_reduce.cc:132:opt_mux$680 }
    New ctrl vector for $pmux cell $procmux$383: $auto$opt_reduce.cc:132:opt_mux$686
    New ctrl vector for $pmux cell $procmux$440: $auto$opt_reduce.cc:132:opt_mux$688
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$669: { $procmux$376_CMP $procmux$375_CMP $procmux$378_CMP $procmux$379_CMP $procmux$380_CMP $procmux$381_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$671: { $procmux$296_CMP $procmux$370_CMP $procmux$375_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$673: { $procmux$270_CMP $procmux$296_CMP $procmux$370_CMP $procmux$376_CMP $procmux$375_CMP $procmux$378_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$675: { $procmux$270_CMP $procmux$296_CMP $procmux$376_CMP $procmux$378_CMP $procmux$379_CMP $procmux$380_CMP $procmux$381_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$677: { $procmux$270_CMP $procmux$376_CMP $procmux$375_CMP $procmux$380_CMP $procmux$381_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$679: { $procmux$275_CMP $procmux$276_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$681: { $procmux$268_CMP $procmux$277_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$683: { $procmux$274_CMP $procmux$280_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$685: { $procmux$270_CMP $procmux$296_CMP $procmux$376_CMP $procmux$378_CMP $procmux$379_CMP $procmux$380_CMP $procmux$381_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$687: { $procmux$378_CMP $procmux$379_CMP }
  Optimizing cells in module \Control.
  Optimizing cells in module \cpu.
  Optimizing cells in module \immGen.
    New ctrl vector for $pmux cell $procmux$458: { $auto$opt_reduce.cc:132:opt_mux$692 $procmux$464_CMP $procmux$463_CMP $procmux$462_CMP $auto$opt_reduce.cc:132:opt_mux$690 $procmux$455_CMP }
    New ctrl vector for $pmux cell $procmux$445: { $auto$opt_reduce.cc:132:opt_mux$696 $auto$opt_reduce.cc:132:opt_mux$694 }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$689: { $procmux$460_CMP $procmux$461_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$691: { $procmux$465_CMP $procmux$466_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$693: { $procmux$446_CMP $procmux$447_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$695: { $procmux$448_CMP $procmux$449_CMP $procmux$450_CMP $procmux$451_CMP $procmux$452_CMP $procmux$453_CMP }
  Optimizing cells in module \immGen.
  Optimizing cells in module \regfile.
    Consolidated identical input bits for $mux cell $procmux$468:
      Old ports: A=0, B=32'11111111111111111111111111111111, Y=$procmux$468_Y
      New ports: A=1'0, B=1'1, Y=$procmux$468_Y [0]
      New connections: $procmux$468_Y [31:1] = { $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] $procmux$468_Y [0] }
    Consolidated identical input bits for $mux cell $procmux$483:
      Old ports: A=32'11111111111111111111111111111111, B=0, Y=$procmux$483_Y
      New ports: A=1'1, B=1'0, Y=$procmux$483_Y [0]
      New connections: $procmux$483_Y [31:1] = { $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] $procmux$483_Y [0] }
  Optimizing cells in module \regfile.
    Consolidated identical input bits for $mux cell $procmux$470:
      Old ports: A=0, B=$procmux$468_Y, Y=$0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147
      New ports: A=1'0, B=$procmux$468_Y [0], Y=$0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0]
      New connections: $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [31:1] = { $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] $0$memwr$\Register_File$regfile.v:21$142_EN[31:0]$147 [0] }
    Consolidated identical input bits for $mux cell $procmux$485:
      Old ports: A=0, B=$procmux$483_Y, Y=$0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150
      New ports: A=1'0, B=$procmux$483_Y [0], Y=$0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0]
      New connections: $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [31:1] = { $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] $0$memwr$\Register_File$regfile.v:23$143_EN[31:0]$150 [0] }
  Optimizing cells in module \regfile.
Performed a total of 28 changes.

6.5.5.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\ALU'.
<suppressed ~3 debug messages>
Finding identical cells in module `\Control'.
<suppressed ~3 debug messages>
Finding identical cells in module `\cpu'.
Finding identical cells in module `\immGen'.
Finding identical cells in module `\regfile'.
Removed a total of 2 cells.

6.5.5.6. Executing OPT_RMDFF pass (remove dff with constant values).

6.5.5.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \ALU..
Finding unused cells or wires in module \Control..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \immGen..
Finding unused cells or wires in module \regfile..
Removed 0 unused cells and 145 unused wires.
<suppressed ~4 debug messages>

6.5.5.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module ALU.
Optimizing module Control.
Optimizing module cpu.
Optimizing module immGen.
Optimizing module regfile.

6.5.5.9. Rerunning OPT passes. (Maybe there is more to do..)

6.5.5.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \ALU..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \Control..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \cpu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \immGen..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~24 debug messages>

6.5.5.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \ALU.
    New ctrl vector for $pmux cell $procmux$518: { $procmux$528_CMP $procmux$527_CMP $procmux$526_CMP $procmux$524_CMP $procmux$523_CMP $procmux$522_CMP $auto$opt_reduce.cc:132:opt_mux$698 $procmux$520_CMP $procmux$519_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$697: { $procmux$504_CMP $procmux$516_CMP }
  Optimizing cells in module \ALU.
  Optimizing cells in module \Control.
  Optimizing cells in module \cpu.
  Optimizing cells in module \immGen.
  Optimizing cells in module \regfile.
Performed a total of 2 changes.

6.5.5.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\ALU'.
Finding identical cells in module `\Control'.
Finding identical cells in module `\cpu'.
Finding identical cells in module `\immGen'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

6.5.5.13. Executing OPT_RMDFF pass (remove dff with constant values).

6.5.5.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \ALU..
Finding unused cells or wires in module \Control..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \immGen..
Finding unused cells or wires in module \regfile..

6.5.5.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module ALU.
Optimizing module Control.
Optimizing module cpu.
Optimizing module immGen.
Optimizing module regfile.

6.5.5.16. Rerunning OPT passes. (Maybe there is more to do..)

6.5.5.17. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \ALU..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \Control..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \cpu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \immGen..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~24 debug messages>

6.5.5.18. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \ALU.
  Optimizing cells in module \Control.
  Optimizing cells in module \cpu.
  Optimizing cells in module \immGen.
  Optimizing cells in module \regfile.
Performed a total of 0 changes.

6.5.5.19. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\ALU'.
Finding identical cells in module `\Control'.
Finding identical cells in module `\cpu'.
Finding identical cells in module `\immGen'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

6.5.5.20. Executing OPT_RMDFF pass (remove dff with constant values).

6.5.5.21. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \ALU..
Finding unused cells or wires in module \Control..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \immGen..
Finding unused cells or wires in module \regfile..

6.5.5.22. Executing OPT_EXPR pass (perform const folding).
Optimizing module ALU.
Optimizing module Control.
Optimizing module cpu.
Optimizing module immGen.
Optimizing module regfile.

6.5.5.23. Finished OPT passes. (There is nothing left to do.)

6.5.6. Executing WREDUCE pass (reducing word size of cells).
Removed top 31 bits (of 32) from mux cell ALU.$procmux$501 ($mux).
Removed top 1 bits (of 4) from port B of cell ALU.$procmux$504_CMP0 ($eq).
Removed top 2 bits (of 4) from port B of cell ALU.$procmux$516_CMP0 ($eq).
Removed top 1 bits (of 4) from port B of cell ALU.$procmux$522_CMP0 ($eq).
Removed top 1 bits (of 4) from port B of cell ALU.$procmux$523_CMP0 ($eq).
Removed top 1 bits (of 4) from port B of cell ALU.$procmux$524_CMP0 ($eq).
Removed top 2 bits (of 4) from port B of cell ALU.$procmux$526_CMP0 ($eq).
Removed top 3 bits (of 4) from port B of cell ALU.$procmux$527_CMP0 ($eq).
Removed top 31 bits (of 32) from wire ALU.$2\out[31:0].
Removed top 1 bits (of 7) from port B of cell Control.$eq$control.v:133$258 ($eq).
Removed top 2 bits (of 7) from port B of cell Control.$procmux$270_CMP0 ($eq).
Removed top 2 bits (of 3) from port B of cell Control.$procmux$274_CMP0 ($eq).
Removed top 1 bits (of 3) from port B of cell Control.$procmux$278_CMP0 ($eq).
Removed top 1 bits (of 3) from port B of cell Control.$procmux$279_CMP0 ($eq).
Removed top 1 bits (of 7) from port B of cell Control.$procmux$296_CMP0 ($eq).
Removed top 1 bits (of 7) from port B of cell Control.$procmux$375_CMP0 ($eq).
Removed top 5 bits (of 7) from port B of cell Control.$procmux$376_CMP0 ($eq).
Removed top 2 bits (of 7) from port B of cell Control.$procmux$380_CMP0 ($eq).
Removed top 1 bits (of 7) from port B of cell Control.$procmux$381_CMP0 ($eq).
Removed top 29 bits (of 32) from port B of cell cpu.$add$cpu.v:55$6 ($add).
Removed top 2 bits (of 3) from port B of cell cpu.$eq$cpu.v:65$26 ($eq).
Removed top 31 bits (of 32) from port B of cell cpu.$eq$cpu.v:66$29 ($eq).
Removed top 2 bits (of 7) from port B of cell cpu.$eq$cpu.v:77$54 ($eq).
Removed top 1 bits (of 7) from port B of cell cpu.$eq$cpu.v:88$64 ($eq).
Removed top 5 bits (of 7) from port B of cell cpu.$eq$cpu.v:142$66 ($eq).
Removed top 16 bits (of 32) from mux cell cpu.$procmux$532 ($pmux).
Removed top 24 bits (of 32) from mux cell cpu.$procmux$542 ($pmux).
Removed top 1 bits (of 2) from port B of cell cpu.$procmux$545_CMP0 ($eq).
Removed top 1 bits (of 3) from port B of cell cpu.$procmux$584_CMP0 ($eq).
Removed top 24 bits (of 32) from wire cpu.$5\drdata_RF[31:0].
Removed top 2 bits (of 4) from wire cpu.$5\dwe_r[3:0].
Removed top 16 bits (of 32) from wire cpu.$6\drdata_RF[31:0].
Removed top 2 bits (of 3) from port B of cell immGen.$procmux$447_CMP0 ($eq).
Removed top 1 bits (of 3) from port B of cell immGen.$procmux$451_CMP0 ($eq).
Removed top 1 bits (of 3) from port B of cell immGen.$procmux$452_CMP0 ($eq).
Removed top 2 bits (of 7) from port B of cell immGen.$procmux$455_CMP0 ($eq).
Removed top 5 bits (of 7) from port B of cell immGen.$procmux$461_CMP0 ($eq).
Removed top 1 bits (of 7) from port B of cell immGen.$procmux$462_CMP0 ($eq).
Removed top 2 bits (of 7) from port B of cell immGen.$procmux$465_CMP0 ($eq).
Removed top 1 bits (of 7) from port B of cell immGen.$procmux$466_CMP0 ($eq).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$155 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$156 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$157 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$158 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$159 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$160 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$161 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$162 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$163 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$164 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$165 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$166 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$167 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$168 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$169 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$170 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$171 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$172 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$173 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$174 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$175 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$176 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$177 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$178 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$179 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$180 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$181 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$182 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$183 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$184 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$185 (Register_File).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Register_File$regfile.v:13$186 (Register_File).
Removed cell regfile.$procmux$473 ($mux).
Removed cell regfile.$procmux$475 ($mux).
Removed cell regfile.$procmux$478 ($mux).
Removed cell regfile.$procmux$480 ($mux).
Removed cell regfile.$procmux$493 ($mux).
Removed cell regfile.$procmux$488 ($mux).
Removed cell regfile.$procmux$490 ($mux).
Removed cell regfile.$procmux$495 ($mux).
Removed cell regfile.$procdff$662 ($dff).
Removed top 31 bits (of 32) from FF cell regfile.$procdff$663 ($dff).
Removed top 31 bits (of 32) from FF cell regfile.$procdff$666 ($dff).

6.5.7. Executing PEEPOPT pass (run peephole optimizers).

6.5.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \ALU..
Finding unused cells or wires in module \Control..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \immGen..
Finding unused cells or wires in module \regfile..
Removed 0 unused cells and 12 unused wires.
<suppressed ~3 debug messages>

6.5.9. Executing TECHMAP pass (map to technology primitives).

6.5.9.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/cmp2lut.v
Parsing Verilog input from `/usr/bin/../share/yosys/cmp2lut.v' to AST representation.
Generating RTLIL representation for module `\_90_lut_cmp_'.
Successfully finished Verilog frontend.

6.5.9.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~512 debug messages>

6.5.10. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module ALU:
  creating $macc model for $add$alu.v:32$70 ($add).
  creating $macc model for $sub$alu.v:55$74 ($sub).
  creating $alu model for $macc $sub$alu.v:55$74.
  creating $alu model for $macc $add$alu.v:32$70.
  creating $alu model for $lt$alu.v:36$71 ($lt): new $alu
  creating $alu cell for $lt$alu.v:36$71: $auto$alumacc.cc:474:replace_alu$704
  creating $alu cell for $add$alu.v:32$70: $auto$alumacc.cc:474:replace_alu$715
  creating $alu cell for $sub$alu.v:55$74: $auto$alumacc.cc:474:replace_alu$718
  created 3 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module Control:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module cpu:
  creating $macc model for $add$cpu.v:55$6 ($add).
  creating $macc model for $add$cpu.v:62$14 ($add).
  creating $macc model for $add$cpu.v:62$18 ($add).
  creating $alu model for $macc $add$cpu.v:62$18.
  creating $alu model for $macc $add$cpu.v:62$14.
  creating $alu model for $macc $add$cpu.v:55$6.
  creating $alu cell for $add$cpu.v:55$6: $auto$alumacc.cc:474:replace_alu$721
  creating $alu cell for $add$cpu.v:62$14: $auto$alumacc.cc:474:replace_alu$724
  creating $alu cell for $add$cpu.v:62$18: $auto$alumacc.cc:474:replace_alu$727
  created 3 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module immGen:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module regfile:
  created 0 $alu and 0 $macc cells.

6.5.11. Executing SHARE pass (SAT-based resource sharing).
Found 3 cells in module ALU that may be considered for resource sharing.
  Analyzing resource sharing options for $sshr$alu.v:66$76 ($sshr):
    Found 1 activation_patterns using ctrl signal $procmux$520_CMP.
    No candidates found.
  Analyzing resource sharing options for $shr$alu.v:47$72 ($shr):
    Found 1 activation_patterns using ctrl signal $procmux$524_CMP.
    No candidates found.
  Analyzing resource sharing options for $shl$alu.v:51$73 ($shl):
    Found 1 activation_patterns using ctrl signal $procmux$523_CMP.
    No candidates found.

6.5.12. Executing OPT pass (performing simple optimizations).

6.5.12.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module ALU.
<suppressed ~1 debug messages>
Optimizing module Control.
Optimizing module cpu.
Optimizing module immGen.
Optimizing module regfile.

6.5.12.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\ALU'.
Finding identical cells in module `\Control'.
Finding identical cells in module `\cpu'.
Finding identical cells in module `\immGen'.
Finding identical cells in module `\regfile'.
<suppressed ~3 debug messages>
Removed a total of 1 cells.

6.5.12.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \ALU..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \Control..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \cpu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \immGen..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~20 debug messages>

6.5.12.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \ALU.
    New input vector for $reduce_and cell $auto$alumacc.cc:64:get_eq$707: { $auto$alumacc.cc:490:replace_alu$705 [0] $auto$alumacc.cc:490:replace_alu$705 [1] $auto$alumacc.cc:490:replace_alu$705 [2] $auto$alumacc.cc:490:replace_alu$705 [3] $auto$alumacc.cc:490:replace_alu$705 [4] $auto$alumacc.cc:490:replace_alu$705 [5] $auto$alumacc.cc:490:replace_alu$705 [6] $auto$alumacc.cc:490:replace_alu$705 [7] $auto$alumacc.cc:490:replace_alu$705 [8] $auto$alumacc.cc:490:replace_alu$705 [9] $auto$alumacc.cc:490:replace_alu$705 [10] $auto$alumacc.cc:490:replace_alu$705 [11] $auto$alumacc.cc:490:replace_alu$705 [12] $auto$alumacc.cc:490:replace_alu$705 [13] $auto$alumacc.cc:490:replace_alu$705 [14] $auto$alumacc.cc:490:replace_alu$705 [15] $auto$alumacc.cc:490:replace_alu$705 [16] $auto$alumacc.cc:490:replace_alu$705 [17] $auto$alumacc.cc:490:replace_alu$705 [18] $auto$alumacc.cc:490:replace_alu$705 [19] $auto$alumacc.cc:490:replace_alu$705 [20] $auto$alumacc.cc:490:replace_alu$705 [21] $auto$alumacc.cc:490:replace_alu$705 [22] $auto$alumacc.cc:490:replace_alu$705 [23] $auto$alumacc.cc:490:replace_alu$705 [24] $auto$alumacc.cc:490:replace_alu$705 [25] $auto$alumacc.cc:490:replace_alu$705 [26] $auto$alumacc.cc:490:replace_alu$705 [27] $auto$alumacc.cc:490:replace_alu$705 [28] $auto$alumacc.cc:490:replace_alu$705 [29] $auto$alumacc.cc:490:replace_alu$705 [30] $auto$alumacc.cc:490:replace_alu$705 [31] }
  Optimizing cells in module \ALU.
  Optimizing cells in module \Control.
  Optimizing cells in module \cpu.
  Optimizing cells in module \immGen.
  Optimizing cells in module \regfile.
Performed a total of 1 changes.

6.5.12.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\ALU'.
Finding identical cells in module `\Control'.
Finding identical cells in module `\cpu'.
Finding identical cells in module `\immGen'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

6.5.12.6. Executing OPT_RMDFF pass (remove dff with constant values).

6.5.12.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \ALU..
Finding unused cells or wires in module \Control..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \immGen..
Finding unused cells or wires in module \regfile..
Removed 1 unused cells and 3 unused wires.
<suppressed ~3 debug messages>

6.5.12.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module ALU.
Optimizing module Control.
Optimizing module cpu.
Optimizing module immGen.
Optimizing module regfile.

6.5.12.9. Rerunning OPT passes. (Maybe there is more to do..)

6.5.12.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \ALU..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \Control..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \cpu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \immGen..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~20 debug messages>

6.5.12.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \ALU.
  Optimizing cells in module \Control.
  Optimizing cells in module \cpu.
  Optimizing cells in module \immGen.
  Optimizing cells in module \regfile.
Performed a total of 0 changes.

6.5.12.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\ALU'.
Finding identical cells in module `\Control'.
Finding identical cells in module `\cpu'.
Finding identical cells in module `\immGen'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

6.5.12.13. Executing OPT_RMDFF pass (remove dff with constant values).

6.5.12.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \ALU..
Finding unused cells or wires in module \Control..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \immGen..
Finding unused cells or wires in module \regfile..

6.5.12.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module ALU.
Optimizing module Control.
Optimizing module cpu.
Optimizing module immGen.
Optimizing module regfile.

6.5.12.16. Finished OPT passes. (There is nothing left to do.)

6.5.13. Executing FSM pass (extract and optimize FSM).

6.5.13.1. Executing FSM_DETECT pass (finding FSMs in design).

6.5.13.2. Executing FSM_EXTRACT pass (extracting FSM from design).

6.5.13.3. Executing FSM_OPT pass (simple optimizations of FSMs).

6.5.13.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \ALU..
Finding unused cells or wires in module \Control..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \immGen..
Finding unused cells or wires in module \regfile..

6.5.13.5. Executing FSM_OPT pass (simple optimizations of FSMs).

6.5.13.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

6.5.13.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

6.5.13.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

6.5.14. Executing OPT pass (performing simple optimizations).

6.5.14.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module ALU.
Optimizing module Control.
Optimizing module cpu.
Optimizing module immGen.
Optimizing module regfile.

6.5.14.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\ALU'.
Finding identical cells in module `\Control'.
Finding identical cells in module `\cpu'.
Finding identical cells in module `\immGen'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

6.5.14.3. Executing OPT_RMDFF pass (remove dff with constant values).

6.5.14.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \ALU..
Finding unused cells or wires in module \Control..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \immGen..
Finding unused cells or wires in module \regfile..

6.5.14.5. Finished fast OPT passes.

6.5.15. Executing MEMORY pass.

6.5.15.1. Executing MEMORY_DFF pass (merging $dff cells to $memrd and $memwr).
Checking cell `$memwr$\Register_File$regfile.v:21$187' in module `\regfile': merged $dff to cell.
Checking cell `$memwr$\Register_File$regfile.v:23$188' in module `\regfile': merged $dff to cell.
Checking cell `$memrd$\Register_File$regfile.v:27$153' in module `\regfile': no (compatible) $dff found.
Checking cell `$memrd$\Register_File$regfile.v:28$154' in module `\regfile': no (compatible) $dff found.

6.5.15.2. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \ALU..
Finding unused cells or wires in module \Control..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \immGen..
Finding unused cells or wires in module \regfile..
Removed 4 unused cells and 4 unused wires.
<suppressed ~5 debug messages>

6.5.15.3. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).
Consolidating write ports of memory regfile.Register_File by address:
  New clock domain: posedge \clk
    Port 0 ($memwr$\Register_File$regfile.v:21$187) has addr \rd.
      Active bits: 11111111111111111111111111111111
    Port 1 ($memwr$\Register_File$regfile.v:23$188) has addr \rd.
      Active bits: 11111111111111111111111111111111
      Merging port 0 into this one.
      Creating logic for merging DATA and EN ports.
      Active bits: 11111111111111111111111111111111

6.5.15.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \ALU..
Finding unused cells or wires in module \Control..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \immGen..
Finding unused cells or wires in module \regfile..

6.5.15.5. Executing MEMORY_COLLECT pass (generating $mem cells).
Collecting $memrd, $memwr and $meminit for memory `\Register_File' in module `\regfile':
  $meminit$\Register_File$regfile.v:13$155 ($meminit)
  $meminit$\Register_File$regfile.v:13$156 ($meminit)
  $meminit$\Register_File$regfile.v:13$157 ($meminit)
  $meminit$\Register_File$regfile.v:13$158 ($meminit)
  $meminit$\Register_File$regfile.v:13$159 ($meminit)
  $meminit$\Register_File$regfile.v:13$160 ($meminit)
  $meminit$\Register_File$regfile.v:13$161 ($meminit)
  $meminit$\Register_File$regfile.v:13$162 ($meminit)
  $meminit$\Register_File$regfile.v:13$163 ($meminit)
  $meminit$\Register_File$regfile.v:13$164 ($meminit)
  $meminit$\Register_File$regfile.v:13$165 ($meminit)
  $meminit$\Register_File$regfile.v:13$166 ($meminit)
  $meminit$\Register_File$regfile.v:13$167 ($meminit)
  $meminit$\Register_File$regfile.v:13$168 ($meminit)
  $meminit$\Register_File$regfile.v:13$169 ($meminit)
  $meminit$\Register_File$regfile.v:13$170 ($meminit)
  $meminit$\Register_File$regfile.v:13$171 ($meminit)
  $meminit$\Register_File$regfile.v:13$172 ($meminit)
  $meminit$\Register_File$regfile.v:13$173 ($meminit)
  $meminit$\Register_File$regfile.v:13$174 ($meminit)
  $meminit$\Register_File$regfile.v:13$175 ($meminit)
  $meminit$\Register_File$regfile.v:13$176 ($meminit)
  $meminit$\Register_File$regfile.v:13$177 ($meminit)
  $meminit$\Register_File$regfile.v:13$178 ($meminit)
  $meminit$\Register_File$regfile.v:13$179 ($meminit)
  $meminit$\Register_File$regfile.v:13$180 ($meminit)
  $meminit$\Register_File$regfile.v:13$181 ($meminit)
  $meminit$\Register_File$regfile.v:13$182 ($meminit)
  $meminit$\Register_File$regfile.v:13$183 ($meminit)
  $meminit$\Register_File$regfile.v:13$184 ($meminit)
  $meminit$\Register_File$regfile.v:13$185 ($meminit)
  $meminit$\Register_File$regfile.v:13$186 ($meminit)
  $memwr$\Register_File$regfile.v:23$188 ($memwr)
  $memrd$\Register_File$regfile.v:27$153 ($memrd)
  $memrd$\Register_File$regfile.v:28$154 ($memrd)

6.5.16. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \ALU..
Finding unused cells or wires in module \Control..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \immGen..
Finding unused cells or wires in module \regfile..

6.6. Executing MEMORY_BRAM pass (mapping $mem cells to block memories).
Processing regfile.Register_File:
  Properties: ports=3 bits=1024 rports=2 wports=1 dbits=32 abits=5 words=32
  Checking rule #1 for bram type $__XILINX_RAMB36_SDP (variant 1):
    Bram geometry: abits=9 dbits=72 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_SDP: awaste=480 dwaste=40 bwaste=35840 waste=35840 efficiency=2
    Rule #1 for bram type $__XILINX_RAMB36_SDP (variant 1) rejected: requirement 'min efficiency 5' not met.
  Checking rule #2 for bram type $__XILINX_RAMB18_SDP (variant 1):
    Bram geometry: abits=9 dbits=36 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_SDP: awaste=480 dwaste=4 bwaste=17408 waste=17408 efficiency=5
    Rule #2 for bram type $__XILINX_RAMB18_SDP (variant 1) rejected: requirement 'min bits 4096' not met.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 1):
    Bram geometry: abits=10 dbits=36 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=992 dwaste=4 bwaste=35840 waste=35840 efficiency=2
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 1) rejected: requirement 'min efficiency 5' not met.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 2):
    Bram geometry: abits=11 dbits=18 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=2016 dwaste=4 bwaste=36416 waste=36416 efficiency=1
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 2) rejected: requirement 'min efficiency 5' not met.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 3):
    Bram geometry: abits=12 dbits=9 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=4064 dwaste=4 bwaste=36704 waste=36704 efficiency=0
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 3) rejected: requirement 'min efficiency 5' not met.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 4):
    Bram geometry: abits=13 dbits=4 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=8160 dwaste=0 bwaste=32640 waste=32640 efficiency=0
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 4) rejected: requirement 'min efficiency 5' not met.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 5):
    Bram geometry: abits=14 dbits=2 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=16352 dwaste=0 bwaste=32704 waste=32704 efficiency=0
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 5) rejected: requirement 'min efficiency 5' not met.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 6):
    Bram geometry: abits=15 dbits=1 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=32736 dwaste=0 bwaste=32736 waste=32736 efficiency=0
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 6) rejected: requirement 'min efficiency 5' not met.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 1):
    Bram geometry: abits=10 dbits=18 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=992 dwaste=4 bwaste=17984 waste=17984 efficiency=2
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 1) rejected: requirement 'min efficiency 5' not met.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 2):
    Bram geometry: abits=11 dbits=9 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=2016 dwaste=4 bwaste=18272 waste=18272 efficiency=1
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 2) rejected: requirement 'min efficiency 5' not met.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 3):
    Bram geometry: abits=12 dbits=4 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=4064 dwaste=0 bwaste=16256 waste=16256 efficiency=0
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 3) rejected: requirement 'min efficiency 5' not met.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 4):
    Bram geometry: abits=13 dbits=2 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=8160 dwaste=0 bwaste=16320 waste=16320 efficiency=0
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 4) rejected: requirement 'min efficiency 5' not met.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 5):
    Bram geometry: abits=14 dbits=1 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=16352 dwaste=0 bwaste=16352 waste=16352 efficiency=0
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 5) rejected: requirement 'min efficiency 5' not met.
  No acceptable bram resources found.

6.7. Executing TECHMAP pass (map to technology primitives).

6.7.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/brams_map.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/brams_map.v' to AST representation.
Generating RTLIL representation for module `\$__XILINX_RAMB36_SDP'.
Generating RTLIL representation for module `\$__XILINX_RAMB18_SDP'.
Generating RTLIL representation for module `\$__XILINX_RAMB36_TDP'.
Generating RTLIL representation for module `\$__XILINX_RAMB18_TDP'.
Successfully finished Verilog frontend.

6.7.2. Continuing TECHMAP pass.
No more expansions possible.

6.8. Executing MEMORY_BRAM pass (mapping $mem cells to block memories).
Processing regfile.Register_File:
  Properties: ports=3 bits=1024 rports=2 wports=1 dbits=32 abits=5 words=32
  Checking rule #1 for bram type $__XILINX_RAM32X1D (variant 1):
    Bram geometry: abits=5 dbits=1 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAM32X1D: awaste=0 dwaste=0 bwaste=0 waste=0 efficiency=100
    Rule #1 for bram type $__XILINX_RAM32X1D (variant 1) accepted.
    Mapping to bram type $__XILINX_RAM32X1D (variant 1):
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain !~async~.
        Mapped to bram port A1.1.
      Read port #1 is in clock domain !~async~.
        Failed to map read port #1.
      Growing more read ports by duplicating bram cells.
      Read port #0 is in clock domain !~async~.
        Mapped to bram port A1.1.
      Read port #1 is in clock domain !~async~.
        Mapped to bram port A1.2.
      Updated properties: dups=2 waste=0 efficiency=50
      Storing for later selection.
  Checking rule #2 for bram type $__XILINX_RAM64X1D (variant 1):
    Bram geometry: abits=6 dbits=1 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAM64X1D: awaste=32 dwaste=0 bwaste=32 waste=32 efficiency=50
    Rule #2 for bram type $__XILINX_RAM64X1D (variant 1) accepted.
    Mapping to bram type $__XILINX_RAM64X1D (variant 1):
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain !~async~.
        Mapped to bram port A1.1.
      Read port #1 is in clock domain !~async~.
        Failed to map read port #1.
      Growing more read ports by duplicating bram cells.
      Read port #0 is in clock domain !~async~.
        Mapped to bram port A1.1.
      Read port #1 is in clock domain !~async~.
        Mapped to bram port A1.2.
      Updated properties: dups=2 waste=64 efficiency=25
      Storing for later selection.
  Checking rule #3 for bram type $__XILINX_RAM128X1D (variant 1):
    Bram geometry: abits=7 dbits=1 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAM128X1D: awaste=96 dwaste=0 bwaste=96 waste=96 efficiency=25
    Rule #3 for bram type $__XILINX_RAM128X1D (variant 1) accepted.
    Mapping to bram type $__XILINX_RAM128X1D (variant 1):
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain !~async~.
        Mapped to bram port A1.1.
      Read port #1 is in clock domain !~async~.
        Failed to map read port #1.
      Growing more read ports by duplicating bram cells.
      Read port #0 is in clock domain !~async~.
        Mapped to bram port A1.1.
      Read port #1 is in clock domain !~async~.
        Mapped to bram port A1.2.
      Updated properties: dups=2 waste=192 efficiency=12
      Storing for later selection.
  Selecting best of 3 rules:
    Efficiency for rule 3.1: efficiency=12, cells=64, acells=1
    Efficiency for rule 2.1: efficiency=25, cells=64, acells=1
    Efficiency for rule 1.1: efficiency=50, cells=64, acells=1
    Selected rule 1.1 with efficiency 50.
    Mapping to bram type $__XILINX_RAM32X1D (variant 1):
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain !~async~.
        Mapped to bram port A1.1.
      Read port #1 is in clock domain !~async~.
        Failed to map read port #1.
      Growing more read ports by duplicating bram cells.
      Read port #0 is in clock domain !~async~.
        Mapped to bram port A1.1.
      Read port #1 is in clock domain !~async~.
        Mapped to bram port A1.2.
      Creating $__XILINX_RAM32X1D cell at grid position <0 0 0>: Register_File.0.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <0 0 1>: Register_File.0.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <1 0 0>: Register_File.1.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <1 0 1>: Register_File.1.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <2 0 0>: Register_File.2.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <2 0 1>: Register_File.2.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <3 0 0>: Register_File.3.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <3 0 1>: Register_File.3.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <4 0 0>: Register_File.4.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <4 0 1>: Register_File.4.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <5 0 0>: Register_File.5.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <5 0 1>: Register_File.5.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <6 0 0>: Register_File.6.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <6 0 1>: Register_File.6.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <7 0 0>: Register_File.7.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <7 0 1>: Register_File.7.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <8 0 0>: Register_File.8.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <8 0 1>: Register_File.8.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <9 0 0>: Register_File.9.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <9 0 1>: Register_File.9.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <10 0 0>: Register_File.10.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <10 0 1>: Register_File.10.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <11 0 0>: Register_File.11.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <11 0 1>: Register_File.11.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <12 0 0>: Register_File.12.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <12 0 1>: Register_File.12.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <13 0 0>: Register_File.13.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <13 0 1>: Register_File.13.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <14 0 0>: Register_File.14.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <14 0 1>: Register_File.14.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <15 0 0>: Register_File.15.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <15 0 1>: Register_File.15.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <16 0 0>: Register_File.16.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <16 0 1>: Register_File.16.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <17 0 0>: Register_File.17.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <17 0 1>: Register_File.17.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <18 0 0>: Register_File.18.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <18 0 1>: Register_File.18.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <19 0 0>: Register_File.19.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <19 0 1>: Register_File.19.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <20 0 0>: Register_File.20.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <20 0 1>: Register_File.20.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <21 0 0>: Register_File.21.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <21 0 1>: Register_File.21.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <22 0 0>: Register_File.22.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <22 0 1>: Register_File.22.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <23 0 0>: Register_File.23.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <23 0 1>: Register_File.23.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <24 0 0>: Register_File.24.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <24 0 1>: Register_File.24.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <25 0 0>: Register_File.25.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <25 0 1>: Register_File.25.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <26 0 0>: Register_File.26.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <26 0 1>: Register_File.26.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <27 0 0>: Register_File.27.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <27 0 1>: Register_File.27.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <28 0 0>: Register_File.28.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <28 0 1>: Register_File.28.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <29 0 0>: Register_File.29.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <29 0 1>: Register_File.29.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <30 0 0>: Register_File.30.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <30 0 1>: Register_File.30.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <31 0 0>: Register_File.31.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <31 0 1>: Register_File.31.0.1

6.9. Executing TECHMAP pass (map to technology primitives).

6.9.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/drams_map.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/drams_map.v' to AST representation.
Generating RTLIL representation for module `\$__XILINX_RAM32X1D'.
Generating RTLIL representation for module `\$__XILINX_RAM64X1D'.
Generating RTLIL representation for module `\$__XILINX_RAM128X1D'.
Successfully finished Verilog frontend.

6.9.2. Continuing TECHMAP pass.
Using template $paramod\$__XILINX_RAM32X1D\INIT=0\CLKPOL2=1 for cells of type $__XILINX_RAM32X1D.
No more expansions possible.
<suppressed ~75 debug messages>

6.10. Executing PMUX2SHIFTX pass.
Inspecting $pmux cell ALU/$procmux$518.
  data width: 32 (next power-of-2 = 32, log2 = 5)
  checking ctrl signal \ALU_control
    best permutation: \ALU_control
    best xor mask: 4'0000
      0: 4'1100 -> 4'1100 -> 4'1100: $xor$alu.v:70$77_Y
      1: 4'1000 -> 4'1000 -> 4'1000: $sshr$alu.v:66$76_Y
      3: 4'0110 -> 4'0110 -> 4'0110: $sub$alu.v:55$74_Y
      4: 4'0101 -> 4'0101 -> 4'0101: $shl$alu.v:51$73_Y
      5: 4'0100 -> 4'0100 -> 4'0100: $shr$alu.v:47$72_Y
      6: 4'0010 -> 4'0010 -> 4'0010: $add$alu.v:32$70_Y
      7: 4'0001 -> 4'0001 -> 4'0001: $or$alu.v:28$69_Y
      8: 4'0000 -> 4'0000 -> 4'0000: $and$alu.v:24$68_Y
    choices: 8
    min choice: 0
    max choice: 12
    range density: 61%
    absolute density: 61%
    full case: false
    created $shiftx cell $auto$pmux2shiftx.cc:720:execute$892.
Inspecting $pmux cell Control/$procmux$272.
  data width: 4 (next power-of-2 = 4, log2 = 2)
  checking ctrl signal \idata [14:12]
    best permutation: \idata [14:12]
    best xor mask: 3'000
      0: 3'101 -> 3'101 -> 3'101: $9\ALU_out_r[3:0]
      1: 3'001 -> 3'001 -> 3'001: 4'0101
      2: 3'111 -> 3'111 -> 3'111: 4'0000
      3: 3'110 -> 3'110 -> 3'110: 4'0001
      4: 3'100 -> 3'100 -> 3'100: 4'1100
      5: 3'011 -> 3'011 -> 3'011: 4'0111
      6: 3'010 -> 3'010 -> 3'010: 4'0011
      7: 3'000 -> 3'000 -> 3'000: 4'0010
    choices: 8
    min choice: 0
    max choice: 7
    range density: 100%
    absolute density: 100%
    full density: 100%
    update to full case.
    new min choice: 0
    new max choice: 7
    full case: true
    created $shiftx cell $auto$pmux2shiftx.cc:720:execute$894.
Inspecting $pmux cell Control/$procmux$345.
  data width: 4 (next power-of-2 = 4, log2 = 2)
  checking ctrl signal \idata [14:12]
    best permutation: \idata [14:12]
    best xor mask: 3'000
      0: 3'111 -> 3'111 -> 3'111: 4'0000
      1: 3'110 -> 3'110 -> 3'110: 4'0001
      2: 3'101 -> 3'101 -> 3'101: $6\ALU_out_r[3:0]
      3: 3'100 -> 3'100 -> 3'100: 4'1100
      4: 3'011 -> 3'011 -> 3'011: 4'0111
      5: 3'010 -> 3'010 -> 3'010: 4'0011
      6: 3'001 -> 3'001 -> 3'001: 4'0101
      7: 3'000 -> 3'000 -> 3'000: $4\ALU_out_r[3:0]
    choices: 8
    min choice: 0
    max choice: 7
    range density: 100%
    absolute density: 100%
    full density: 100%
    update to full case.
    new min choice: 0
    new max choice: 7
    full case: true
    created $shiftx cell $auto$pmux2shiftx.cc:720:execute$896.
Inspecting $pmux cell Control/$procmux$372.
  data width: 4 (next power-of-2 = 4, log2 = 2)
  checking ctrl signal \idata [6:0]
    best permutation: { \idata [3:0] \idata [6:4] }
    best xor mask: 7'0011000
      0: 7'0010011 -> 7'0011001 -> 7'0000001: $8\ALU_out_r[3:0]
      1: 7'0110011 -> 7'0011011 -> 7'0000011: $3\ALU_out_r[3:0]
      3: 7'1100011 -> 7'0011110 -> 7'0000110: $2\ALU_out_r[3:0]
    choices: 3
    min choice: 1
    max choice: 6
    range density: 50%
    absolute density: 42%
    full case: false
    offset: 7'0000001
    created $shiftx cell $auto$pmux2shiftx.cc:720:execute$904.
Inspecting $pmux cell cpu/$procmux$542.
  data width: 8 (next power-of-2 = 8, log2 = 3)
  checking ctrl signal \daddr [1:0]
    best permutation: \daddr [1:0]
    best xor mask: 2'00
      0: 2'11 -> 2'11 -> 2'11: \drdata [31:24]
      1: 2'10 -> 2'10 -> 2'10: \drdata [23:16]
      2: 2'01 -> 2'01 -> 2'01: \drdata [15:8]
      3: 2'00 -> 2'00 -> 2'00: \drdata [7:0]
    choices: 4
    min choice: 0
    max choice: 3
    range density: 100%
    absolute density: 100%
    full density: 100%
    update to full case.
    new min choice: 0
    new max choice: 3
    full case: true
    created $shiftx cell $auto$pmux2shiftx.cc:720:execute$906.
Inspecting $pmux cell cpu/$procmux$570.
  data width: 32 (next power-of-2 = 32, log2 = 5)
  checking ctrl signal \daddr [1:0]
    best permutation: \daddr [1:0]
    best xor mask: 2'00
      0: 2'11 -> 2'11 -> 2'11: { \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31:24] }
      1: 2'10 -> 2'10 -> 2'10: { \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23:16] }
      2: 2'01 -> 2'01 -> 2'01: { \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15:8] }
      3: 2'00 -> 2'00 -> 2'00: { \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7:0] }
    choices: 4
    min choice: 0
    max choice: 3
    range density: 100%
    absolute density: 100%
    full density: 100%
    update to full case.
    new min choice: 0
    new max choice: 3
    full case: true
    created $shiftx cell $auto$pmux2shiftx.cc:720:execute$908.
Inspecting $pmux cell cpu/$procmux$581.
  data width: 32 (next power-of-2 = 32, log2 = 5)
  checking ctrl signal \idata [14:12]
    best permutation: \idata [14:12]
    best xor mask: 3'000
      0: 3'101 -> 3'101 -> 3'101: { 16'0000000000000000 $6\drdata_RF[31:0] }
      1: 3'100 -> 3'100 -> 3'100: { 24'000000000000000000000000 $5\drdata_RF[31:0] }
      2: 3'010 -> 3'010 -> 3'010: \drdata
      3: 3'001 -> 3'001 -> 3'001: $4\drdata_RF[31:0]
      4: 3'000 -> 3'000 -> 3'000: $3\drdata_RF[31:0]
    choices: 5
    min choice: 0
    max choice: 5
    range density: 83%
    absolute density: 83%
    full density: 62%
    update to full case.
    new min choice: 0
    new max choice: 7
    full case: true
    created $shiftx cell $auto$pmux2shiftx.cc:720:execute$910.
Inspecting $pmux cell cpu/$procmux$616.
  data width: 4 (next power-of-2 = 4, log2 = 2)
  checking ctrl signal \daddr [1:0]
    best permutation: \daddr [1:0]
    best xor mask: 2'00
      0: 2'11 -> 2'11 -> 2'11: 4'1000
      1: 2'10 -> 2'10 -> 2'10: 4'0100
      2: 2'01 -> 2'01 -> 2'01: 4'0010
      3: 2'00 -> 2'00 -> 2'00: 4'0001
    choices: 4
    min choice: 0
    max choice: 3
    range density: 100%
    absolute density: 100%
    full density: 100%
    update to full case.
    new min choice: 0
    new max choice: 3
    full case: true
    created $shiftx cell $auto$pmux2shiftx.cc:720:execute$912.
Inspecting $pmux cell cpu/$procmux$627.
  data width: 4 (next power-of-2 = 4, log2 = 2)
  checking ctrl signal \idata [14:12]
    table of choices:
      0: 3'010: { $auto$wreduce.cc:455:run$701 [3:2] $5\dwe_r[3:0] }
      1: 3'001: $4\dwe_r[3:0]
      2: 3'000: $3\dwe_r[3:0]
    failed to detect onehot driver. do not optimize.
Inspecting $pmux cell cpu/$procmux$635.
  data width: 32 (next power-of-2 = 32, log2 = 5)
  checking ctrl signal \idata [14:12]
    table of choices:
      0: 3'010: \data2
      1: 3'001: { \data2 [15:0] \data2 [15:0] }
      2: 3'000: { \data2 [7:0] \data2 [7:0] \data2 [7:0] \data2 [7:0] }
    failed to detect onehot driver. do not optimize.
Inspecting $pmux cell immGen/$procmux$458.
  data width: 32 (next power-of-2 = 32, log2 = 5)
  checking ctrl signal \idata [6:0]
    best permutation: { \idata [1:0] \idata [6:2] }
    best xor mask: 7'1100000
      0: 7'0010011 -> 7'1100100 -> 7'0000100: $2\imm_r[31:0]
      2: 7'0100011 -> 7'1101000 -> 7'0001000: { \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31:25] \idata [11:7] }
      3: 7'1100011 -> 7'1111000 -> 7'0011000: { \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [7] \idata [30:25] \idata [11:8] 1'0 }
      4: 7'1101111 -> 7'1111011 -> 7'0011011: { \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [19:12] \idata [20] \idata [30:21] 1'0 }
    choices: 4
    min choice: 4
    max choice: 27
    range density: 16%
    absolute density: 14%
    full case: false
    insufficient density.

6.11. Executing OPT pass (performing simple optimizations).

6.11.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module ALU.
<suppressed ~2 debug messages>
Optimizing module Control.
<suppressed ~8 debug messages>
Optimizing module cpu.
<suppressed ~6 debug messages>
Optimizing module immGen.
<suppressed ~1 debug messages>
Optimizing module regfile.
<suppressed ~29 debug messages>

6.11.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\ALU'.
Finding identical cells in module `\Control'.
Finding identical cells in module `\cpu'.
Finding identical cells in module `\immGen'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

6.11.3. Executing OPT_RMDFF pass (remove dff with constant values).

6.11.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \ALU..
Finding unused cells or wires in module \Control..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \immGen..
Finding unused cells or wires in module \regfile..
Removed 20 unused cells and 492 unused wires.
<suppressed ~26 debug messages>

6.11.5. Finished fast OPT passes.

6.12. Executing MEMORY_MAP pass (converting $mem cells to logic and flip-flops).

6.13. Executing DFFSR2DFF pass (mapping DFFSR cells to simpler FFs).

6.14. Executing DFF2DFFE pass (transform $dff to $dffe where applicable).
Transforming FF to FF+Enable cells in module ALU:
Transforming FF to FF+Enable cells in module Control:
Transforming FF to FF+Enable cells in module cpu:
Transforming FF to FF+Enable cells in module immGen:
Transforming FF to FF+Enable cells in module regfile:

6.15. Executing OPT pass (performing simple optimizations).

6.15.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module ALU.
Optimizing module Control.
Optimizing module cpu.
Optimizing module immGen.
Optimizing module regfile.

6.15.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\ALU'.
Finding identical cells in module `\Control'.
Finding identical cells in module `\cpu'.
<suppressed ~3 debug messages>
Finding identical cells in module `\immGen'.
Finding identical cells in module `\regfile'.
Removed a total of 1 cells.

6.15.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \ALU..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \Control..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \cpu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \immGen..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~18 debug messages>

6.15.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \ALU.
  Optimizing cells in module \Control.
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$685: { \MemtoReg $procmux$270_CMP $procmux$296_CMP $procmux$378_CMP $procmux$379_CMP $procmux$380_CMP $procmux$381_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$677: { \MemtoReg $procmux$270_CMP $procmux$375_CMP $procmux$380_CMP $procmux$381_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$673: { \branch \MemtoReg $procmux$270_CMP $procmux$296_CMP $procmux$375_CMP $procmux$378_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$671: { \branch $procmux$296_CMP $procmux$375_CMP }
    Consolidated identical input bits for $mux cell $procmux$265:
      Old ports: A=4'0100, B=4'1000, Y=$9\ALU_out_r[3:0]
      New ports: A=2'01, B=2'10, Y=$9\ALU_out_r[3:0] [3:2]
      New connections: $9\ALU_out_r[3:0] [1:0] = 2'00
    Consolidated identical input bits for $mux cell $procmux$288:
      Old ports: A=4'1111, B=4'0100, Y=$7\ALU_out_r[3:0]
      New ports: A=1'1, B=1'0, Y=$7\ALU_out_r[3:0] [0]
      New connections: $7\ALU_out_r[3:0] [3:1] = { $7\ALU_out_r[3:0] [0] 1'1 $7\ALU_out_r[3:0] [0] }
    Consolidated identical input bits for $mux cell $procmux$318:
      Old ports: A=4'1111, B=4'0010, Y=$5\ALU_out_r[3:0]
      New ports: A=1'1, B=1'0, Y=$5\ALU_out_r[3:0] [0]
      New connections: $5\ALU_out_r[3:0] [3:1] = { $5\ALU_out_r[3:0] [0] $5\ALU_out_r[3:0] [0] 1'1 }
    Consolidated identical input bits for $pmux cell $procmux$362:
      Old ports: A=4'1111, B=12'011000110111, Y=$2\ALU_out_r[3:0]
      New ports: A=3'111, B=9'010001011, Y={ $2\ALU_out_r[3:0] [3:2] $2\ALU_out_r[3:0] [0] }
      New connections: $2\ALU_out_r[3:0] [1] = 1'1
  Optimizing cells in module \Control.
    Consolidated identical input bits for $mux cell $procmux$302:
      Old ports: A=$7\ALU_out_r[3:0], B=4'1000, Y=$6\ALU_out_r[3:0]
      New ports: A={ $7\ALU_out_r[3:0] [0] 1'1 $7\ALU_out_r[3:0] [0] }, B=3'100, Y={ $6\ALU_out_r[3:0] [3:2] $6\ALU_out_r[3:0] [0] }
      New connections: $6\ALU_out_r[3:0] [1] = $6\ALU_out_r[3:0] [0]
    Consolidated identical input bits for $mux cell $procmux$337:
      Old ports: A=$5\ALU_out_r[3:0], B=4'0110, Y=$4\ALU_out_r[3:0]
      New ports: A={ $5\ALU_out_r[3:0] [0] $5\ALU_out_r[3:0] [0] }, B=2'10, Y={ $4\ALU_out_r[3:0] [2] $4\ALU_out_r[3:0] [0] }
      New connections: { $4\ALU_out_r[3:0] [3] $4\ALU_out_r[3:0] [1] } = { $4\ALU_out_r[3:0] [0] 1'1 }
  Optimizing cells in module \Control.
  Optimizing cells in module \cpu.
    Consolidated identical input bits for $pmux cell $procmux$557:
      Old ports: A=0, B={ \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15:0] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31:16] }, Y=$4\drdata_RF[31:0]
      New ports: A=16'0000000000000000, B={ \drdata [15:0] \drdata [31:16] }, Y=$4\drdata_RF[31:0] [15:0]
      New connections: $4\drdata_RF[31:0] [31:16] = { $4\drdata_RF[31:0] [15] $4\drdata_RF[31:0] [15] $4\drdata_RF[31:0] [15] $4\drdata_RF[31:0] [15] $4\drdata_RF[31:0] [15] $4\drdata_RF[31:0] [15] $4\drdata_RF[31:0] [15] $4\drdata_RF[31:0] [15] $4\drdata_RF[31:0] [15] $4\drdata_RF[31:0] [15] $4\drdata_RF[31:0] [15] $4\drdata_RF[31:0] [15] $4\drdata_RF[31:0] [15] $4\drdata_RF[31:0] [15] $4\drdata_RF[31:0] [15] $4\drdata_RF[31:0] [15] }
    Consolidated identical input bits for $mux cell $procmux$595:
      Old ports: A=4'0000, B=4'1111, Y={ $auto$wreduce.cc:455:run$701 [3:2] $5\dwe_r[3:0] }
      New ports: A=1'0, B=1'1, Y=$5\dwe_r[3:0] [0]
      New connections: { $auto$wreduce.cc:455:run$701 [3:2] $5\dwe_r[3:0] [1] } = { $5\dwe_r[3:0] [0] $5\dwe_r[3:0] [0] $5\dwe_r[3:0] [0] }
    Consolidated identical input bits for $pmux cell $procmux$605:
      Old ports: A=4'0000, B=8'00111100, Y=$4\dwe_r[3:0]
      New ports: A=2'00, B=4'0110, Y={ $4\dwe_r[3:0] [2] $4\dwe_r[3:0] [0] }
      New connections: { $4\dwe_r[3:0] [3] $4\dwe_r[3:0] [1] } = { $4\dwe_r[3:0] [2] $4\dwe_r[3:0] [0] }
  Optimizing cells in module \cpu.
  Optimizing cells in module \immGen.
    Consolidated identical input bits for $mux cell $procmux$445:
      Old ports: A={ \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31] \idata [31:20] }, B={ 27'000000000000000000000000000 \idata [24:20] }, Y=$2\imm_r[31:0]
      New ports: A=\idata [31:25], B=7'0000000, Y=$2\imm_r[31:0] [11:5]
      New connections: { $2\imm_r[31:0] [31:12] $2\imm_r[31:0] [4:0] } = { $2\imm_r[31:0] [11] $2\imm_r[31:0] [11] $2\imm_r[31:0] [11] $2\imm_r[31:0] [11] $2\imm_r[31:0] [11] $2\imm_r[31:0] [11] $2\imm_r[31:0] [11] $2\imm_r[31:0] [11] $2\imm_r[31:0] [11] $2\imm_r[31:0] [11] $2\imm_r[31:0] [11] $2\imm_r[31:0] [11] $2\imm_r[31:0] [11] $2\imm_r[31:0] [11] $2\imm_r[31:0] [11] $2\imm_r[31:0] [11] $2\imm_r[31:0] [11] $2\imm_r[31:0] [11] $2\imm_r[31:0] [11] $2\imm_r[31:0] [11] \idata [24:20] }
  Optimizing cells in module \immGen.
  Optimizing cells in module \regfile.
Performed a total of 14 changes.

6.15.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\ALU'.
Finding identical cells in module `\Control'.
<suppressed ~3 debug messages>
Finding identical cells in module `\cpu'.
<suppressed ~3 debug messages>
Finding identical cells in module `\immGen'.
Finding identical cells in module `\regfile'.
Removed a total of 2 cells.

6.15.6. Executing OPT_RMDFF pass (remove dff with constant values).

6.15.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \ALU..
Finding unused cells or wires in module \Control..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \immGen..
Finding unused cells or wires in module \regfile..
Removed 0 unused cells and 4 unused wires.
<suppressed ~2 debug messages>

6.15.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module ALU.
Optimizing module Control.
<suppressed ~1 debug messages>
Optimizing module cpu.
<suppressed ~1 debug messages>
Optimizing module immGen.
Optimizing module regfile.

6.15.9. Rerunning OPT passes. (Maybe there is more to do..)

6.15.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \ALU..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \Control..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \cpu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \immGen..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~17 debug messages>

6.15.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \ALU.
  Optimizing cells in module \Control.
  Optimizing cells in module \cpu.
  Optimizing cells in module \immGen.
  Optimizing cells in module \regfile.
Performed a total of 0 changes.

6.15.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\ALU'.
Finding identical cells in module `\Control'.
Finding identical cells in module `\cpu'.
Finding identical cells in module `\immGen'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

6.15.13. Executing OPT_RMDFF pass (remove dff with constant values).

6.15.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \ALU..
Finding unused cells or wires in module \Control..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \immGen..
Finding unused cells or wires in module \regfile..
Removed 0 unused cells and 1 unused wires.
<suppressed ~1 debug messages>

6.15.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module ALU.
Optimizing module Control.
Optimizing module cpu.
Optimizing module immGen.
Optimizing module regfile.

6.15.16. Finished OPT passes. (There is nothing left to do.)

6.16. Executing SIMPLEMAP pass (map simple cells to gate primitives).
Mapping cpu.$procdff$667 ($dff).
Mapping cpu.$procdff$668 ($dff).

6.17. Executing SHREGMAP pass (map shift registers).
Converted 0 dff cells into 0 shift registers.

6.18. Executing TECHMAP pass (map to technology primitives).

6.18.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/techmap.v
Parsing Verilog input from `/usr/bin/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

6.18.2. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/arith_map.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/arith_map.v' to AST representation.
Generating RTLIL representation for module `\_80_xilinx_lcu'.
Generating RTLIL representation for module `\_80_xilinx_alu'.
Successfully finished Verilog frontend.

6.18.3. Continuing TECHMAP pass.
Using extmapper simplemap for cells of type $or.
Using extmapper simplemap for cells of type $eq.
Using extmapper simplemap for cells of type $and.
Using extmapper simplemap for cells of type $mux.
Using extmapper simplemap for cells of type $logic_not.
Using extmapper simplemap for cells of type $reduce_bool.
Using template $paramod$bf3b5fab9e093d19bbea16c6516a73d098dbaa75\_80_xilinx_alu for cells of type $alu.
Using extmapper simplemap for cells of type $not.
Using template $paramod$constmap:e7214e8bd05a28e58319966b0df5f8236d0271c3$paramod$9852e737f52c689a5201940ede7b10a925704df2\_90_shift_shiftx for cells of type $shiftx.
Using template $paramod$constmap:ad62432dc588384ac9e4502cee6ddae521345b24$paramod$616bc737fc20a0b56f184bcda6509db70a8b8664\_90_shift_shiftx for cells of type $shiftx.
Using template $paramod\_90_pmux\WIDTH=16\S_WIDTH=2 for cells of type $pmux.
Using template $paramod$constmap:72f169cfb8bfa9048819c8bedc6b295364572284$paramod$e82f95b66701918fca10f3cd05193671f64c61b0\_90_shift_shiftx for cells of type $shiftx.
Using template $paramod$constmap:cfe18f9dcbf321cb6311994a8efc1e30675937c3$paramod$7293aed416beb8760e5389a199e73fea480f82b9\_90_shift_shiftx for cells of type $shiftx.
Using template $paramod$ed0e7b60ee0d374b6722444b11ce7533faf826e2\_80_xilinx_alu for cells of type $alu.
Using template $paramod\_90_pmux\WIDTH=2\S_WIDTH=2 for cells of type $pmux.
Using template $paramod\_90_pmux\WIDTH=4\S_WIDTH=3 for cells of type $pmux.
Using template $paramod\_90_pmux\WIDTH=32\S_WIDTH=3 for cells of type $pmux.
Using extmapper simplemap for cells of type $xor.
Using extmapper simplemap for cells of type $pos.
Using extmapper simplemap for cells of type $reduce_or.
Using template $paramod\_90_pmux\WIDTH=32\S_WIDTH=6 for cells of type $pmux.
Running "alumacc" on wrapper $extern:wrap:$sub:A_SIGNED=0:A_WIDTH=7:B_SIGNED=0:B_WIDTH=7:Y_WIDTH=7:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$sub:A_SIGNED=0:A_WIDTH=7:B_SIGNED=0:B_WIDTH=7:Y_WIDTH=7:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$sub:A_SIGNED=0:A_WIDTH=7:B_SIGNED=0:B_WIDTH=7:Y_WIDTH=7:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $paramod$constmap:85e00f6e244313c892c7d32a4bec6b545053240f$paramod$0abe75bf1371b57bef758f60e5922232bac805f8\_90_shift_shiftx for cells of type $shiftx.
Using template $paramod$constmap:925fe5fe7df865b77fc2e4b1b6e3a3bb26be3ee7$paramod$1d315e053015f90eab3af4490b48924d04f52834\_90_shift_shiftx for cells of type $shift.
Using template $paramod\_90_pmux\WIDTH=3\S_WIDTH=3 for cells of type $pmux.
Analyzing pattern of constant bits for this cell:
  Constant input on bit 1 of port A: 1'1
  Bit 3 of port A and bit 0 of port A are connected.
  Constant input on bit 4 of port A: 1'1
  Constant input on bit 5 of port A: 1'0
  Constant input on bit 6 of port A: 1'1
  Constant input on bit 7 of port A: 1'0
  Constant input on bit 8 of port A: 1'1
  Constant input on bit 9 of port A: 1'1
  Constant input on bit 10 of port A: 1'0
  Constant input on bit 11 of port A: 1'0
  Constant input on bit 12 of port A: 1'1
  Constant input on bit 13 of port A: 1'1
  Constant input on bit 14 of port A: 1'1
  Constant input on bit 15 of port A: 1'0
  Constant input on bit 16 of port A: 1'0
  Constant input on bit 17 of port A: 1'0
  Constant input on bit 18 of port A: 1'1
  Constant input on bit 19 of port A: 1'1
  Bit 21 of port A and bit 20 of port A are connected.
  Constant input on bit 24 of port A: 1'1
  Constant input on bit 25 of port A: 1'0
  Constant input on bit 26 of port A: 1'0
  Constant input on bit 27 of port A: 1'0
  Constant input on bit 28 of port A: 1'0
  Constant input on bit 29 of port A: 1'0
  Constant input on bit 30 of port A: 1'0
  Constant input on bit 31 of port A: 1'0
  Constant input on bit 0 of port B: 1'0
  Constant input on bit 1 of port B: 1'0
Creating constmapped module `$paramod$constmap:f0ee021119394da3c1c87a94663ee28e3558762f$paramod$0abe75bf1371b57bef758f60e5922232bac805f8\_90_shift_shiftx'.

6.18.52. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod$constmap:f0ee021119394da3c1c87a94663ee28e3558762f$paramod$0abe75bf1371b57bef758f60e5922232bac805f8\_90_shift_shiftx..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 2/2 on $mux $procmux$4858.
    dead port 2/2 on $mux $procmux$4855.
    dead port 2/2 on $mux $procmux$4849.
    dead port 2/2 on $mux $procmux$4846.
    dead port 2/2 on $mux $procmux$4840.
    dead port 2/2 on $mux $procmux$4837.
    dead port 1/2 on $mux $procmux$4834.
    dead port 1/2 on $mux $procmux$4831.
    dead port 2/2 on $mux $procmux$4831.
    dead port 1/2 on $mux $procmux$4828.
    dead port 2/2 on $mux $procmux$4828.
    dead port 1/2 on $mux $procmux$4825.
    dead port 1/2 on $mux $procmux$4822.
    dead port 2/2 on $mux $procmux$4822.
    dead port 1/2 on $mux $procmux$4819.
    dead port 2/2 on $mux $procmux$4819.
Removed 16 multiplexer ports.
<suppressed ~1442 debug messages>

6.18.53. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod$constmap:f0ee021119394da3c1c87a94663ee28e3558762f$paramod$0abe75bf1371b57bef758f60e5922232bac805f8\_90_shift_shiftx.
Removed 0 unused cells and 16 unused wires.
Using template $paramod$constmap:f0ee021119394da3c1c87a94663ee28e3558762f$paramod$0abe75bf1371b57bef758f60e5922232bac805f8\_90_shift_shiftx for cells of type $shiftx.
Using template $paramod$constmap:99cea28b091b145f74667eab0cb6eb52b62557d4$paramod$ba696c209216a59b86db0a948b1249b7c4de2736\_90_shift_shiftx for cells of type $shiftx.
Using template $paramod\_90_pmux\WIDTH=4\S_WIDTH=2 for cells of type $pmux.
Using template $paramod$71fe29f31c06a098de76e755526458481e81b0f6\_80_xilinx_alu for cells of type $alu.
Using template $paramod$constmap:b9a86d073741c2a0f7bb241e73c2dd11747f3288$paramod$5be353ef5531baf885e010532ba16fbb2d5d1d8e\_90_shift_ops_shr_shl_sshl_sshr for cells of type $shr.
Using template $paramod$constmap:b9a86d073741c2a0f7bb241e73c2dd11747f3288$paramod$8c0dd5ff1d42c73e7701ae7a633831fc809160d1\_90_shift_ops_shr_shl_sshl_sshr for cells of type $shl.
Using template $paramod$constmap:b9a86d073741c2a0f7bb241e73c2dd11747f3288$paramod$b111673ca623818545fde5f982932658d8112ff6\_90_shift_ops_shr_shl_sshl_sshr for cells of type $sshr.
Using template $paramod$constmap:484d6315b2ec1fcb49a08270bca82ce90d25a91f$paramod$02e8aa25978beb8503092f7bc844068daf86225a\_90_shift_shiftx for cells of type $shift.
Using template $paramod$2827e7d34c07400d403bef957360fef4bde6a36b\_80_xilinx_alu for cells of type $alu.
Using template $paramod$constmap:a4cdfaf9398a575e45f0a63e39a99b4c7a506a10$paramod$149fb4d4fc58926e274282524ef85225e3c05042\_90_shift_shiftx for cells of type $shiftx.
Using template $paramod\_90_pmux\WIDTH=32\S_WIDTH=2 for cells of type $pmux.
Using extmapper simplemap for cells of type $reduce_and.
No more expansions possible.
<suppressed ~2150 debug messages>

6.19. Executing OPT pass (performing simple optimizations).

6.19.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module ALU.
<suppressed ~593 debug messages>
Optimizing module Control.
<suppressed ~142 debug messages>
Optimizing module cpu.
<suppressed ~374 debug messages>
Optimizing module immGen.
<suppressed ~55 debug messages>
Optimizing module regfile.
<suppressed ~1 debug messages>

6.19.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\ALU'.
<suppressed ~579 debug messages>
Finding identical cells in module `\Control'.
<suppressed ~549 debug messages>
Finding identical cells in module `\cpu'.
<suppressed ~2460 debug messages>
Finding identical cells in module `\immGen'.
<suppressed ~597 debug messages>
Finding identical cells in module `\regfile'.
Removed a total of 1395 cells.

6.19.3. Executing OPT_RMDFF pass (remove dff with constant values).

6.19.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \ALU..
Finding unused cells or wires in module \Control..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \immGen..
Finding unused cells or wires in module \regfile..
Removed 1364 unused cells and 801 unused wires.
<suppressed ~1369 debug messages>

6.19.5. Finished fast OPT passes.

6.20. Executing TECHMAP pass (map to technology primitives).

6.20.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/techmap.v
Parsing Verilog input from `/usr/bin/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

6.20.2. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/cells_map.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/cells_map.v' to AST representation.
Generating RTLIL representation for module `\_90_dff_nn0_to_np0'.
Generating RTLIL representation for module `\_90_dff_pn0_to_pp0'.
Generating RTLIL representation for module `\_90_dff_nn1_to_np1'.
Generating RTLIL representation for module `\_90_dff_pn1_to_pp1'.
Generating RTLIL representation for module `\$__SHREG_'.
Generating RTLIL representation for module `\$__XILINX_SHREG_'.
Successfully finished Verilog frontend.

6.20.3. Continuing TECHMAP pass.
No more expansions possible.

6.21. Executing ABC pass (technology mapping using ABC).

6.21.1. Extracting gate netlist of module `\ALU' to `<abc-temp-dir>/input.blif'..
Extracted 1446 gates and 1582 wires to a netlist network with 133 inputs and 222 outputs.

6.21.1.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_lut <abc-temp-dir>/lutdefs.txt 
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + dch -f 
ABC: + if 
ABC: + mfs2 
ABC: Currently "mfs" cannot process the network containing nodes with more than 6 fanins.
ABC: + write_blif <abc-temp-dir>/output.blif 

6.21.1.2. Re-integrating ABC results.
ABC RESULTS:              $lut cells:     1530
ABC RESULTS:        internal signals:     1227
ABC RESULTS:           input signals:      133
ABC RESULTS:          output signals:      222
Removing temp directory.

6.21.2. Extracting gate netlist of module `\Control' to `<abc-temp-dir>/input.blif'..
Extracted 199 gates and 241 wires to a netlist network with 39 inputs and 32 outputs.

6.21.2.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_lut <abc-temp-dir>/lutdefs.txt 
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + dch -f 
ABC: + if 
ABC: + mfs2 
ABC: Currently "mfs" cannot process the network containing nodes with more than 6 fanins.
ABC: + write_blif <abc-temp-dir>/output.blif 

6.21.2.2. Re-integrating ABC results.
ABC RESULTS:              $lut cells:       92
ABC RESULTS:        internal signals:      170
ABC RESULTS:           input signals:       39
ABC RESULTS:          output signals:       32
Removing temp directory.

6.21.3. Extracting gate netlist of module `\cpu' to `<abc-temp-dir>/input.blif'..
Extracted 1082 gates and 1387 wires to a netlist network with 303 inputs and 292 outputs.

6.21.3.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_lut <abc-temp-dir>/lutdefs.txt 
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + dch -f 
ABC: + if 
ABC: + mfs2 
ABC: Currently "mfs" cannot process the network containing nodes with more than 6 fanins.
ABC: + write_blif <abc-temp-dir>/output.blif 

6.21.3.2. Re-integrating ABC results.
ABC RESULTS:              $lut cells:      832
ABC RESULTS:        internal signals:      792
ABC RESULTS:           input signals:      303
ABC RESULTS:          output signals:      292
Removing temp directory.

6.21.4. Extracting gate netlist of module `\immGen' to `<abc-temp-dir>/input.blif'..
Extracted 269 gates and 303 wires to a netlist network with 32 inputs and 32 outputs.

6.21.4.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_lut <abc-temp-dir>/lutdefs.txt 
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + dch -f 
ABC: + if 
ABC: + mfs2 
ABC: Currently "mfs" cannot process the network containing nodes with more than 6 fanins.
ABC: + write_blif <abc-temp-dir>/output.blif 

6.21.4.2. Re-integrating ABC results.
ABC RESULTS:              $lut cells:       84
ABC RESULTS:        internal signals:      239
ABC RESULTS:           input signals:       32
ABC RESULTS:          output signals:       32
Removing temp directory.

6.21.5. Extracting gate netlist of module `\regfile' to `<abc-temp-dir>/input.blif'..
Extracted 168 gates and 206 wires to a netlist network with 38 inputs and 33 outputs.

6.21.5.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_lut <abc-temp-dir>/lutdefs.txt 
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + dch -f 
ABC: + if 
ABC: + mfs2 
ABC: Currently "mfs" cannot process the network containing nodes with more than 6 fanins.
ABC: + write_blif <abc-temp-dir>/output.blif 

6.21.5.2. Re-integrating ABC results.
ABC RESULTS:              $lut cells:       66
ABC RESULTS:        internal signals:      135
ABC RESULTS:           input signals:       38
ABC RESULTS:          output signals:       33
Removing temp directory.
Removed 0 unused cells and 1060 unused wires.

6.22. Executing SHREGMAP pass (map shift registers).
Converted 0 dff cells into 0 shift registers.

6.23. Executing TECHMAP pass (map to technology primitives).

6.23.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/lut_map.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/lut_map.v' to AST representation.
Generating RTLIL representation for module `\$lut'.
Successfully finished Verilog frontend.

6.23.2. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/ff_map.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/ff_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NN0_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_PN0_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_NN1_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PN1_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Successfully finished Verilog frontend.

6.23.3. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/cells_map.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/cells_map.v' to AST representation.
Generating RTLIL representation for module `\_90_dff_nn0_to_np0'.
Generating RTLIL representation for module `\_90_dff_pn0_to_pp0'.
Generating RTLIL representation for module `\_90_dff_nn1_to_np1'.
Generating RTLIL representation for module `\_90_dff_pn1_to_pp1'.
Generating RTLIL representation for module `\$__SHREG_'.
Generating RTLIL representation for module `\$__XILINX_SHREG_'.
Successfully finished Verilog frontend.

6.23.4. Continuing TECHMAP pass.
Using template $paramod\$lut\WIDTH=1\LUT=2'01 for cells of type $lut.
Using template \$_DFF_P_ for cells of type $_DFF_P_.
Using template $paramod\$lut\WIDTH=2\LUT=4'0100 for cells of type $lut.
Using template $paramod$5a31a5003eee007045c57c3e5beed68301a0fe54\$lut for cells of type $lut.
Using template $paramod$7e2384d4d4e6cca2af00a01510cb6c995640c691\$lut for cells of type $lut.
Using template $paramod$a60395c1983d7e97a3c220db397a96eb1227475c\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'00010000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'1000 for cells of type $lut.
Using template $paramod$ccce4f3946ebc1c1bbc18bd1adc9add9d368a18e\$lut for cells of type $lut.
Using template $paramod$53afc4693cdd4770ebaebeb0ab6c288fde062f75\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'0001 for cells of type $lut.
Using template $paramod$6c6748f1c0c0e14d3dc1ee48df9f15ed805bc2da\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'10111110 for cells of type $lut.
Using template $paramod$f275b2d97237f5f7d3462ef47444def2125c8869\$lut for cells of type $lut.
Using template $paramod$89ffd657527df9c0d71b3e9bec4b0a4a4f4f7623\$lut for cells of type $lut.
Using template $paramod$af81859745334ef3d0ddafd478e258634893b6f1\$lut for cells of type $lut.
Using template $paramod$f666527485349d45efd82f932ce87b413d86f431\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=786442 for cells of type $lut.
Using template $paramod$a833723cbeedfe577e5fe3feae743d421f484bb0\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'00000111 for cells of type $lut.
Using template $paramod$cab32a0b219a659fbc19dc88f45d865c68115a19\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1000000000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=1073741824 for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=32'11110000111100001100110010101010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'11001010 for cells of type $lut.
Using template $paramod$730b89cab6bada469e37891942c4f6b2f93e2696\$lut for cells of type $lut.
Using template $paramod$3da916e1c5705810970d14a41b8c266d3136a8ba\$lut for cells of type $lut.
Using template $paramod$2372381f45d474b3eb5c787077cd8c0e73353efe\$lut for cells of type $lut.
Using template $paramod$8d331b7bfadc3644e8cf484512e5be899aa9a490\$lut for cells of type $lut.
Using template $paramod$bb30728d549f53d1c148314040bccf8af142dec9\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'01110000 for cells of type $lut.
Using template $paramod$7bee01fd6ef2cabc2837b1d2097f408aa38e32e8\$lut for cells of type $lut.
Using template $paramod$7d1ea751ddcb52b812bc3ae3eb6b14776c1ecac7\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=32'11001010000000000000000000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=32'11111111010011110100010001000100 for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'0110 for cells of type $lut.
Using template $paramod$f5fed460b3eac63293a6aae841460330b49e2f75\$lut for cells of type $lut.
Using template $paramod$1929d44748517239e36a599c0facfb62ddb99607\$lut for cells of type $lut.
Using template $paramod$bac363bb68b991c6acd35c38b3e75867a2cf7867\$lut for cells of type $lut.
Using template $paramod$aff236128e621f905715598ef0a7177fd40b1a16\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0001000000000000 for cells of type $lut.
Using template $paramod$c77ddd4ad6dad01669bd5b152b2e76174b1b2097\$lut for cells of type $lut.
Using template $paramod$b3bfcb1b8c360ce257ac9f6dbee513afdd5f650c\$lut for cells of type $lut.
Using template $paramod$056bcf12ab18330080284c962e2c496addef9d32\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'10101100 for cells of type $lut.
Using template $paramod$95c6a64df76131b90399696387f6e4430aa0bf89\$lut for cells of type $lut.
Using template $paramod$f213b751f2a49686b126a3ebb30391425ffc0b30\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1111010001000100 for cells of type $lut.
Using template $paramod$32bb39d76fc7a8f8e275e40fbdb04bbe9c27df86\$lut for cells of type $lut.
Using template $paramod$d3854e401fe5b8b146829835823fbfb0b0c02108\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'01000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=32'11111111111100010000000000000000 for cells of type $lut.
Using template $paramod$db7f90fbb79a337197408a616150afe40a49a553\$lut for cells of type $lut.
Using template $paramod$476310105343afc524a013bc8113ed82ad9fcc56\$lut for cells of type $lut.
Using template $paramod$28c0787ccc12daa63318773b6293e301ddad329f\$lut for cells of type $lut.
Using template $paramod$a2b30ef1109f2d58e70b9bab045e63ed6f141d5c\$lut for cells of type $lut.
Using template $paramod$9c1fdb72bfab429eb035e50b86046f0edb412905\$lut for cells of type $lut.
Using template $paramod$57d9f5f3be37e3d29793c980ae9b7560e5c03fe2\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=32'11111111000111110000000000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'00000001 for cells of type $lut.
Using template $paramod$48f2dbf37d164a0205d71bfbe591bc4a915212e0\$lut for cells of type $lut.
Using template $paramod$406845586954900e1c71b862485bf3dd60edfd56\$lut for cells of type $lut.
Using template $paramod$aa715321dd3f63f1d7aca98103d14a27cbb49da8\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1110111111111111 for cells of type $lut.
Using template $paramod$0876cf76f4459eed88e70e2f1c7d326bfa851d41\$lut for cells of type $lut.
Using template $paramod$ce1962f796a7f3665f0c805bea1ad272a3aa4cc9\$lut for cells of type $lut.
Using template $paramod$a4ef7ebf7a41c7b6d5c6222cc7f695f97b2fd307\$lut for cells of type $lut.
Using template $paramod$ebd50d145037f209f7bd5c1dda5a0b522d50cde5\$lut for cells of type $lut.
Using template $paramod$0f5699e5c3fc69a3c1ed2ff6e5675a8cff65976d\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'1110 for cells of type $lut.
Using template $paramod$cb21546ff2adae06302e7fb525ed8574e430a4f1\$lut for cells of type $lut.
Using template $paramod$3db2a4075202e9771df46babcc2f7472d6009419\$lut for cells of type $lut.
Using template $paramod$41ddac21dfa7169eeb79f70cd626e7c1cc7bffe2\$lut for cells of type $lut.
Using template $paramod$32ef4b311a1ce3840975bed7d676059b92f83528\$lut for cells of type $lut.
Using template $paramod$b5cd238a527d851ba52055b76f8b8313ff4d0a1d\$lut for cells of type $lut.
Using template $paramod$ff57678d373b23988f875602c1716e7508b5c3bb\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000000000000001 for cells of type $lut.
Using template $paramod$7004ef649e73e113b8851814c1542b8fe4722838\$lut for cells of type $lut.
Using template $paramod$cee1e9bc56c4d182e88f2f891d9a34d7f852abb5\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'11100000 for cells of type $lut.
Using template $paramod$5fd40f1f3197260017359014257be4170ee5f0b9\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'00001110 for cells of type $lut.
Using template $paramod$b8d3ffd16ce1df0cbcd327716e1f99981f57197f\$lut for cells of type $lut.
Using template $paramod$91109551e45187363078df58c643dc40fbd51e2e\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'00001101 for cells of type $lut.
Using template $paramod$66e6ce4a9f5b93de62d326b15818f206f6d01a10\$lut for cells of type $lut.
Using template $paramod$62ef5dc5b2ef500636874d4a88611ba8dd139086\$lut for cells of type $lut.
Using template $paramod$36823977709853d7de59cfd8f07978699979f33f\$lut for cells of type $lut.
Using template $paramod$62232b1e4a05254ffc857c55b15929bd0afe0232\$lut for cells of type $lut.
Using template $paramod$75f41d511cee275ba588b32a1222c8112565620e\$lut for cells of type $lut.
Using template $paramod$262012ba926dc773dd0144c657d52dea3283faca\$lut for cells of type $lut.
Using template $paramod$b1bd2a921ec0f1ea0cc7578a2bcf32d761c7f62f\$lut for cells of type $lut.
Using template $paramod$9616576ef712a946970b0b431804a32df1acb624\$lut for cells of type $lut.
Using template $paramod$c995e831fb1fdbc7b136aca56382666d0f3951a0\$lut for cells of type $lut.
Using template $paramod$9cc2e2c91ddef856ea0e6f225f50b9139d50648b\$lut for cells of type $lut.
Using template $paramod$ddc02ba62f546c197bb474717c475de8e490211e\$lut for cells of type $lut.
Using template $paramod$8f3693c0cccee51ca00e7ed5caa5ffe1a51a9cbf\$lut for cells of type $lut.
Using template $paramod$84ddf6316c157662d7157880f6560e615a291800\$lut for cells of type $lut.
Using template $paramod$ca0540151d6f8c00fa839fc047b051c7914efb48\$lut for cells of type $lut.
Using template $paramod$6df7a8846901f4baf80e0bf20c371765b1ec2db3\$lut for cells of type $lut.
Using template $paramod$56f3e246421b6b29fd066d86d01fc72a1f44c94f\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1111111000000000 for cells of type $lut.
Using template $paramod$1d1818d1f1b1719676dd231e382e918f6e9a16a2\$lut for cells of type $lut.
Using template $paramod$33a8b4c8a84ca536dbdd4fea6c96842757b1a355\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=65536 for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=1 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1001000000001001 for cells of type $lut.
Using template $paramod$5547587bde2f1ca8d884d89fe5b90567ab8bb30e\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'10000000 for cells of type $lut.
Using template $paramod$4266f47e50d92aaa9f0abe526e1897112700a1b7\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1100101000000000 for cells of type $lut.
Using template $paramod$00f6cba238ea214be03fa32251bd15d834c374df\$lut for cells of type $lut.
Using template $paramod$2f74a2494baea61d34ba3b1cac331e94abf1b33d\$lut for cells of type $lut.
Using template $paramod$28ac21fe76d18e84eb8c0cf0b2860e02a40f1aa0\$lut for cells of type $lut.
Using template $paramod$be9289cd913be0fbf90465083eb65787e64a6146\$lut for cells of type $lut.
Using template $paramod$25916dcdf99c595b1641921631b462b97a7fb708\$lut for cells of type $lut.
Using template $paramod$53e1d89bedaba82e909b6212faee2e44ae2059dc\$lut for cells of type $lut.
Using template $paramod$0d162d9c5c3127365e70653be44d05f6430c4b70\$lut for cells of type $lut.
Using template $paramod$2112a70fa1dfed7009af2d1b2a9304edd7f76cef\$lut for cells of type $lut.
Using template $paramod$368395b52d1cebad446a7428ebf03fbb142a8485\$lut for cells of type $lut.
Using template $paramod$820febb99cfba715e5545ddd667bd36c3205d4ac\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=32'10101010111111000000000000000000 for cells of type $lut.
Using template $paramod$415a62358290b70884679c86908ca13925457cd5\$lut for cells of type $lut.
Using template $paramod$13dfb0bc6675b7370799a1cca33cc9c147f14423\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=4079 for cells of type $lut.
Using template $paramod$aba08ac59cb2052ea68498350ba1866893d52d41\$lut for cells of type $lut.
Using template $paramod$0142f2f9cdc28ccdc6b129734f281be5ac9f3f59\$lut for cells of type $lut.
Using template $paramod$f1b894255ac59bcc49ab0b559872cb4b005cc794\$lut for cells of type $lut.
Using template $paramod$213893e739821fe6ac278c01fd59f963f21ea2c7\$lut for cells of type $lut.
Using template $paramod$af11618743749a47d7c1305e4122c67f0e5cd468\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=256114688 for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=44863 for cells of type $lut.
Using template $paramod$37db0ba99a98ccfb46a254760bef5cc5243f5dbd\$lut for cells of type $lut.
Using template $paramod$9a7c408d10d1c4f6a8e85b796b62e3676b538313\$lut for cells of type $lut.
Using template $paramod$0917682acf1660887668d460bf1f7a5b514e1216\$lut for cells of type $lut.
Using template $paramod$1be6720883c7c31d160eef01258a2ff7f98b3f0d\$lut for cells of type $lut.
Using template $paramod$52c5822cd8afb365c47a78dad2342c93d111b529\$lut for cells of type $lut.
Using template $paramod$de99bd4471fb993dbc15fe3246b0d4a8f2d56626\$lut for cells of type $lut.
Using template $paramod$db3395e98f6f2249a16ea95cf96004ce57c143f8\$lut for cells of type $lut.
Using template $paramod$6305bea2049314474329c24b6615ab2d9739e87a\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=32'11111111000000001111111111110100 for cells of type $lut.
Using template $paramod$c5d2206909726f7f72588cf48f1bb7c11513cb07\$lut for cells of type $lut.
Using template $paramod$63dd51087290ae05350839ad60db7febc34021c8\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=61199 for cells of type $lut.
Using template $paramod$fe5a68b3b639010a18a371d7283c3a6f14b6b131\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=987409 for cells of type $lut.
Using template $paramod$7b60ca93e0abeb1ffe1d79f39931e1fe181be2ee\$lut for cells of type $lut.
Using template $paramod$1cdc73ab3c90fd08af601ead6bf90ef4a1ae2514\$lut for cells of type $lut.
Using template $paramod$a40cb5e950d6848e79681686526b60d182b7499a\$lut for cells of type $lut.
Using template $paramod$97cde1eab73d1dc41d5762d7215378af3f195065\$lut for cells of type $lut.
Using template $paramod$e44085319a2bf29cd7a0c38c9e230d0e33e04b25\$lut for cells of type $lut.
Using template $paramod$07ffb7d9551e25df67d56858490d04820996e378\$lut for cells of type $lut.
Using template $paramod$db0ba4bf379f356ae3f92b75a821b6ab62796306\$lut for cells of type $lut.
Using template $paramod$46d7faeb6e284d94a5b3669b8f007feeaee1a336\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0001111100000000 for cells of type $lut.
Using template $paramod$88b26ed76754a153f8d8b30de456105d276ccc87\$lut for cells of type $lut.
Using template $paramod$c56c77475f9e4da3721c0cfa869c0f90b0695563\$lut for cells of type $lut.
Using template $paramod$cae9fa572513fa7dbc249262e8f443e288509740\$lut for cells of type $lut.
Using template $paramod$a75247e7c5a0c476c85517c0e6fbbc483ff4f699\$lut for cells of type $lut.
Using template $paramod$5438b7427216b3301b1e8399ed1e4c8b4ee41571\$lut for cells of type $lut.
Using template $paramod$48289a9cc967af1c0a9f17b5ae5b9bcb7746c86b\$lut for cells of type $lut.
Using template $paramod$85889a0497b6986c61b1705f68bc41111b12ca39\$lut for cells of type $lut.
Using template $paramod$4c9c6845cc95b5ef2df77848ff72ffe24b527a3e\$lut for cells of type $lut.
Using template $paramod$3ad2958f869dbec7b03e7e0bf6bd34b14fb271d8\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=520093696 for cells of type $lut.
Using template $paramod$a438cb5599a374b1cc654e1fdfc59912b287550c\$lut for cells of type $lut.
Using template $paramod$808356b49fe679434b01b3c9069a9f61765ed281\$lut for cells of type $lut.
Using template $paramod$d35ad0e996994cc3faa6896b6a976a374d17749d\$lut for cells of type $lut.
Using template $paramod$09fc16232a842e4a8efaea352eaf6ec83a042e5e\$lut for cells of type $lut.
Using template $paramod$1e3d20f15384cd0a8020eba6b33ff56fb0935527\$lut for cells of type $lut.
Using template $paramod$6e22e588f5b7077e40229676cdf198b4b5e9c07a\$lut for cells of type $lut.
Using template $paramod$03993a85288e743c33bc3fc0dc2e5fa01a94e2bc\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=859439104 for cells of type $lut.
Using template $paramod$99b277baaeffbb174fd0a40edcce58a23a49f4cd\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'11010000 for cells of type $lut.
Using template $paramod$18fe7b715a2d1e5238c45fe27ae4935943d14d0a\$lut for cells of type $lut.
Using template $paramod$86ab00e544558e9d46e065224f75cd9d090b15ab\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0111011101110000 for cells of type $lut.
Using template $paramod$5269d90755cd70b0364548655c235caac09ea2a1\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'00110101 for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=489335 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1110111100000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=32'11101111111111110000000000000000 for cells of type $lut.
Using template $paramod$064847e53e01e0962d8d829364aa5967d8a412ff\$lut for cells of type $lut.
Using template $paramod$edad49495046faa3fe7f77f2dac415d34912da5b\$lut for cells of type $lut.
Using template $paramod$9791372543ca899ced37883c99f22f563fc6ff8c\$lut for cells of type $lut.
Using template $paramod$765fd22108e052805b1dcd79940fda675bacb904\$lut for cells of type $lut.
Using template $paramod$32d03bd0ccdab09e8c3dacfe9abb6354194a6779\$lut for cells of type $lut.
Using template $paramod$deecd9f1538b780021375f350654f6a0630cb02d\$lut for cells of type $lut.
Using template $paramod$54ac61f61d99a24dd13099baa5cd832053e7c684\$lut for cells of type $lut.
Using template $paramod$dc54698de1e7aa431a6526ba2768f8209d844ab5\$lut for cells of type $lut.
Using template $paramod$f384af5ab1468eab286e135164efd09ee40f4912\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=1996947456 for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=32'10001111100010000000000000000000 for cells of type $lut.
Using template $paramod$2a4dfacba46b8ecd433a7aacb329b058c3a0e778\$lut for cells of type $lut.
Using template $paramod$449fd08e99c5c5aec2acca42d6bf5c9f35131a41\$lut for cells of type $lut.
Using template $paramod$e3f24dcf0b8713f4c322772fe821721da95d28e9\$lut for cells of type $lut.
Using template $paramod$2e112d4acf7e2a1e2058273696a87647988eb463\$lut for cells of type $lut.
Using template $paramod$92b138aa770148c27cfdc1c4325afc9a26f15cff\$lut for cells of type $lut.
Using template $paramod$f71230dd88e33a95326a45e4571566ee639e8210\$lut for cells of type $lut.
Using template $paramod$cca09ea1f2bfb3e6c992d09b34d38e4b40bf9a2d\$lut for cells of type $lut.
Using template $paramod$2b8d3ed3a226b72de1743ee7da856fa004b637b5\$lut for cells of type $lut.
Using template $paramod$505849f6b48657fcc076a0b88b2214efe617a6e2\$lut for cells of type $lut.
Using template $paramod$f54649332605ed1c83ed97de60e68e59b5bbb3e9\$lut for cells of type $lut.
Using template $paramod$4919f5f947ca314af7db86e3a1565b8db08ebb58\$lut for cells of type $lut.
Using template $paramod$0e7a9991bc94234f97e3280a0908837349168bba\$lut for cells of type $lut.
Using template $paramod$4f1acf161e78d6ebe87f3818e7c95f3e67e8cff0\$lut for cells of type $lut.
Using template $paramod$1399ad359e23286e943ef10953a0135a0665a88b\$lut for cells of type $lut.
Using template $paramod$6a9a146e4737084a5040b9ce2d4d0e3b496012a4\$lut for cells of type $lut.
Using template $paramod$67589f2cde5ad5c4a6367db951440411bef24a4c\$lut for cells of type $lut.
Using template $paramod$ff4553be37b750ac3a95e0c0b61a9a0136c0109f\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000111100010001 for cells of type $lut.
Using template $paramod$ba479a210228a49f9d0672a2bf39c475116425cf\$lut for cells of type $lut.
Using template $paramod$d332c140cb4923288068d8a82e6bd6c03cf3cbdd\$lut for cells of type $lut.
Using template $paramod$7012bab5649dacd44bfe5f55417a97c8590630ae\$lut for cells of type $lut.
Using template $paramod$eaaf4e12934c621719dc02af3572cc159f79b7f8\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=13430954 for cells of type $lut.
Using template $paramod$ffc107aea797b4531b40cc919ba7dded11448023\$lut for cells of type $lut.
Using template $paramod$5d47ec1c404db961663a942fdb0b21c4cb22071f\$lut for cells of type $lut.
Using template $paramod$986abb8f6255d07b220c8b1986c9adeb4ed9d7d6\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000000000011111 for cells of type $lut.
Using template $paramod$6214ef81953f3edb7f127b97113f574050478bf2\$lut for cells of type $lut.
Using template $paramod$e756e5464501861e958e8545415ba88d7cb579b1\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=252706696 for cells of type $lut.
Using template $paramod$815d527596033e45ac2bc410aed3cd4bf182ce5b\$lut for cells of type $lut.
Using template $paramod$1d57624106410853ae998e114d508bba91e50f7b\$lut for cells of type $lut.
Using template $paramod$74f9bc1ffd51785c4363f9dc7961f229ff9bb8db\$lut for cells of type $lut.
Using template $paramod$fbd8f90e6edf797d5713291e0ccfc3180400c111\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=252645188 for cells of type $lut.
Using template $paramod$ce50b141d87356120fc8c67a1ad638605a765059\$lut for cells of type $lut.
Using template $paramod$b3828332b7aa58de44365e8513892b898446b568\$lut for cells of type $lut.
Using template $paramod$995f6c7b62aeb3c67a0baa5e9e45c184ffc34956\$lut for cells of type $lut.
Using template $paramod$e25f73e563296d4eff2f5a20f1a8c7f9419abbc1\$lut for cells of type $lut.
Using template $paramod$80dec5c712eef4f19fe69efe78ea866fe86d90f7\$lut for cells of type $lut.
Using template $paramod$51039d731688b7cd1b03be3906283ed0ca16f0f3\$lut for cells of type $lut.
Using template $paramod$b4376c7af5813f24212043a009e4255665c4382d\$lut for cells of type $lut.
Using template $paramod$330773f3f74c21b9448066341fed00a1e1ea1d3e\$lut for cells of type $lut.
Using template $paramod$e1ccd5c959ebdc71666452a568d48c6b44cebcb4\$lut for cells of type $lut.
Using template $paramod$0fa25edf6b73e4b08c339321ed94fc59cfd3fe0a\$lut for cells of type $lut.
Using template $paramod$1b4231f27e15838b8d7dbe40fbf969a3697d3931\$lut for cells of type $lut.
Using template $paramod$e73347aaf119300c0c1929c2350d5a0cf5f96ca0\$lut for cells of type $lut.
Using template $paramod$821a69bf72a395a27d383dc59dd03b82258a06b8\$lut for cells of type $lut.
Using template $paramod$21cc90b3006e377f36d5d32c8b7024bcc8a7ce72\$lut for cells of type $lut.
No more expansions possible.
<suppressed ~3994 debug messages>

6.24. Executing DFFINIT pass (set INIT param on FF cells).
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$936.INIT (port=Q, net=\iaddr [12]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$934.INIT (port=Q, net=\iaddr [10]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$931.INIT (port=Q, net=\iaddr [7]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$932.INIT (port=Q, net=\iaddr [8]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$953.INIT (port=Q, net=\iaddr [29]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$933.INIT (port=Q, net=\iaddr [9]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$949.INIT (port=Q, net=\iaddr [25]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$948.INIT (port=Q, net=\iaddr [24]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$930.INIT (port=Q, net=\iaddr [6]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$941.INIT (port=Q, net=\iaddr [17]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$924.INIT (port=Q, net=\iaddr [0]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$952.INIT (port=Q, net=\iaddr [28]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$927.INIT (port=Q, net=\iaddr [3]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$928.INIT (port=Q, net=\iaddr [4]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$935.INIT (port=Q, net=\iaddr [11]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$939.INIT (port=Q, net=\iaddr [15]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$937.INIT (port=Q, net=\iaddr [13]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$938.INIT (port=Q, net=\iaddr [14]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$956.INIT (port=Q, net=\start) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$929.INIT (port=Q, net=\iaddr [5]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$925.INIT (port=Q, net=\iaddr [1]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$926.INIT (port=Q, net=\iaddr [2]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$946.INIT (port=Q, net=\iaddr [22]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$940.INIT (port=Q, net=\iaddr [16]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$951.INIT (port=Q, net=\iaddr [27]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$942.INIT (port=Q, net=\iaddr [18]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$954.INIT (port=Q, net=\iaddr [30]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$943.INIT (port=Q, net=\iaddr [19]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$947.INIT (port=Q, net=\iaddr [23]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$955.INIT (port=Q, net=\iaddr [31]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$950.INIT (port=Q, net=\iaddr [26]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$944.INIT (port=Q, net=\iaddr [20]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$945.INIT (port=Q, net=\iaddr [21]) to 1'0.
Removed 0 unused cells and 2697 unused wires.

6.25. Executing HIERARCHY pass (managing design hierarchy).

6.25.1. Analyzing design hierarchy..
Top module:  \cpu
Used module:     \Control
Used module:     \immGen
Used module:     \regfile
Used module:     \ALU

6.25.2. Analyzing design hierarchy..
Top module:  \cpu
Used module:     \Control
Used module:     \immGen
Used module:     \regfile
Used module:     \ALU
Removed 0 unused modules.

6.26. Printing statistics.

=== ALU ===

   Number of wires:               1950
   Number of wire bits:           2170
   Number of public wires:           5
   Number of public wire bits:     132
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:               2067
     LUT1                           64
     LUT2                          188
     LUT3                           72
     LUT4                           66
     LUT5                           29
     LUT6                          918
     MUXCY                          94
     MUXF7                         403
     MUXF8                         169
     XORCY                          64

   Estimated number of LCs:       1128

=== Control ===

   Number of wires:                 60
   Number of wire bits:            127
   Number of public wires:          20
   Number of public wire bits:      81
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 69
     LUT1                            6
     LUT2                           19
     LUT3                            1
     LUT4                            2
     LUT5                            1
     LUT6                           21
     MUXCY                           6
     MUXF7                           5
     MUXF8                           1
     XORCY                           7

   Estimated number of LCs:         36

=== cpu ===

   Number of wires:                486
   Number of wire bits:           1000
   Number of public wires:          25
   Number of public wire bits:     415
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                751
     ALU                             1
     Control                         1
     FDRE                           33
     LUT1                            2
     LUT2                          175
     LUT3                           39
     LUT4                           10
     LUT5                           51
     LUT6                          194
     MUXCY                          93
     MUXF7                          47
     MUXF8                           8
     XORCY                          95
     immGen                          1
     regfile                         1

   Estimated number of LCs:        357

=== immGen ===

   Number of wires:                 57
   Number of wire bits:            150
   Number of public wires:           3
   Number of public wire bits:      96
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 86
     LUT3                            1
     LUT4                            5
     LUT5                            7
     LUT6                           51
     MUXF7                          20
     MUXF8                           2

   Estimated number of LCs:         64

=== regfile ===

   Number of wires:                105
   Number of wire bits:            241
   Number of public wires:           9
   Number of public wire bits:     145
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                160
     LUT6                           64
     MUXF7                          32
     RAM32X1D                       64

   Estimated number of LCs:         64

=== design hierarchy ===

   cpu                               1
     ALU                             1
     Control                         1
     immGen                          1
     regfile                         1

   Number of wires:               2658
   Number of wire bits:           3688
   Number of public wires:          62
   Number of public wire bits:     869
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:               3129
     FDRE                           33
     LUT1                           72
     LUT2                          382
     LUT3                          113
     LUT4                           83
     LUT5                           88
     LUT6                         1248
     MUXCY                         193
     MUXF7                         507
     MUXF8                         180
     RAM32X1D                       64
     XORCY                         166

   Estimated number of LCs:       1625

6.27. Executing CHECK pass (checking for obvious problems).
checking module ALU..
checking module Control..
checking module cpu..
checking module immGen..
checking module regfile..
found and reported 0 problems.

7. Executing Verilog backend.
Dumping module `\ALU'.
Dumping module `\Control'.
Dumping module `\cpu'.
Dumping module `\immGen'.
Dumping module `\regfile'.

End of script. Logfile hash: 12a7c2709f
CPU: user 6.94s system 0.29s, MEM: 179.70 MB total, 174.21 MB resident
Yosys 0.9 (git sha1 1979e0b)
Time spent: 19% 2x write_verilog (1 sec), 17% 22x read_verilog (1 sec), ...
Compiling sources for post-synthesis simulation
Ensure all required files listed in program_files_synth.txt
Using directory : ./test/t1
Compiling sources
RUNNING TEST FROM ./test/t1
Using directory : ./test/t2
Compiling sources
RUNNING TEST FROM ./test/t2
Using directory : ./test/t3
Compiling sources
WARNING: imem.v:9: $readmemh(./test/t3/idata.mem): Not enough words in the file for the requested range [0:4095].
RUNNING TEST FROM ./test/t3
Passed

You should see a PASS message and all tests pass.
If any test reports as a FAIL, fix it before submitting.
Once all tests pass, commit the changes into your code,
and push the commit back to the server for evaluation.
